     1                                  ; Subst!
     2                                  
     3                                  [map all ./lst/subst.map]
     4                                  [DEFAULT REL]
     5                                  
     6                                  ;
     7                                  ;Creates, deletes and displays subst drives.
     8                                  ;Order of arguments DOES NOT matter.
     9                                  ;Invoked by: 
    10                                  ; SUBST [drive 1: [drive2:]path] <- Mounts [drive2:]path on drive1:
    11                                  ; SUBST drive1: /D       <- Deletes the subst drive drive1:
    12                                  ; SUBST                  <- Displays current subst drives
    13                                  
    14                                  BITS 64
    15                                  %include "./inc/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1> %%_ret:
    14                              <1>     ret
    15                              <1> %assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro cret 1
    19                              <1> %%_base:
    20                              <1> %assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    21                              <1>     %ifdef retOff
    22                              <1>     %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <1>     %ifdef currSegVBase
    24                              <1>     j%+1 short (retOff+currSegVBase)
    25                              <1>     %else
    26                              <1>     j%+1 short retOff
    27                              <1>     %endif  ;End ifdef currSegVBase
    28                              <1>     %else 
    29                              <1>     j%-1 short %%a
    30                              <1>     return
    31                              <1> %%a:
    32                              <1>     %endif  ;End the distance measurement if
    33                              <1>     %else   
    34                              <1>     j%-1 short %%a
    35                              <1>     return
    36                              <1> %%a:
    37                              <1>     %endif  ;End ifdef retoff
    38                              <1> %endmacro
    39                              <1> 
    40                              <1> %macro retz 0
    41                              <1> cret z
    42                              <1> %endmacro
    43                              <1> 
    44                              <1> %macro retnz 0
    45                              <1> cret nz
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> %macro rete 0
    49                              <1> cret e
    50                              <1> %endmacro
    51                              <1> 
    52                              <1> %macro retne 0
    53                              <1> cret ne
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> %macro retc 0
    57                              <1> cret c
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> %macro retnc 0
    61                              <1> cret nc
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> %macro retb 0
    65                              <1> cret b
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro retnb 0
    69                              <1> cret nb
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro reta 0
    73                              <1> cret a
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro retna 0
    77                              <1> cret na
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro breakpoint 0
    81                              <1> xchg bx, bx
    82                              <1> %endmacro
    16                                  %include "./inc/dosStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous internal     ;
     4                              <1> ; SCP/DOS structures.                                   ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> ;------------------------------------------------------------------------;
     8                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
     9                              <1> ; its file system structure. This is used to locate files and structures
    10                              <1> ; on the device itself and to translate file requests to cluster chains
    11                              <1> ; to LBAs to pass to the disk driver..
    12                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    13                              <1> ; drivers Initialise routine has been called.
    14                              <1> ;------------------------------------------------------------------------;
    15                              <1> struc dpb        ;Drive Parameter Block
    16                              <1> 
    17 00000000 ??                  <1>     .bDriveNumber            db ?  ;Drive number (0=A, 1=B ...)
    18 00000001 ??                  <1>     .bUnitNumber             db ?  ;Unit number in device
    19 00000002 ????                <1>     .wBytesPerSector         dw ?  ;min 512, max 4096
    20 00000004 ??                  <1>     .bMaxSectorInCluster     db ?  ;(Maximum sector in cluster) - 1
    21 00000005 ??                  <1>     .bSectorsPerClusterShift db ?  ;Sectors per cluster exponent
    22 00000006 ????                <1>     .wFAToffset              dw ?  ;Number of reserved sectors in partition
    23 00000008 ??                  <1>     .bNumberOfFATs           db ?  ;Number of FATs
    24 00000009 ????                <1>     .wNumberRootDirEntries   dw ?  ;In 32 byte units, this is 0 for FAT32
    25 0000000B ????????            <1>     .dClusterHeapOffset      dd ?  ;Start sector of data area
    26 0000000F ????????            <1>     .dClusterCount           dd ?  ;Total number of clusters in data area
    27 00000013 ????????            <1>     .dFATlength              dd ?  ;FAT length, in sectors
    28 00000017 ????????            <1>     .dFirstUnitOfRootDir     dd ?  
    29                              <1>     ;Unit=Sector/Cluster of Root Directory (FAT12/16 = Sector, FAT32 = Cluster)
    30 0000001B ????????????????    <1>     .qDriverHeaderPtr        dq ?  ;Pointer to device driver header
    31 00000023 ??                  <1>     .bMediaDescriptor        db ?  ;Media descriptor
    32 00000024 ??                  <1>     .bAccessFlag             db ?  ;Access Flag (0 if accessed, else -1)
    33 00000025 ????????????????    <1>     .qNextDPBPtr             dq ?  ;Pointer to next DPB, -1 if at end
    34 0000002D ????????            <1>     .dFirstFreeCluster       dd ?  ;Starting cluster of free space search
    35 00000031 ????????            <1>     .dNumberOfFreeClusters   dd ?  ;Number of free clusters, -1 unknown
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> fat12MaxClustCnt    equ 4085    ;Cluster count less than this is FAT12
    40                              <1> fat16MaxClustCnt    equ 65525   ;Cluster count less than this is FAT16
    41                              <1> ;------------------------------------------------------------------------;
    42                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    43                              <1> ; All disk pathing requests go via the CDS for that drive.
    44                              <1> ; The default drive is the last accessed drive, this number is stored
    45                              <1> ; in the DOS data area.
    46                              <1> ; The CDS is stored as an array with the offset into the array being 
    47                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    48                              <1> ;
    49                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    50                              <1> ;------------------------------------------------------------------------;
    51                              <1> struc cds       ;Current Directory structure
    52 00000000 <res 43h>           <1>     .sCurrentPath        db 67 dup (?)    ;Current Directory Path String
    53 00000043 ????                <1>     .wFlags              dw ?   ;CDS Flags - 
    54 00000045 ????????????????    <1>     .qDPBPtr             dq ?   ;Ptr to the DPB of the dev using this CDS
    55 0000004D ????????            <1>     .dStartCluster       dd ?   ;Starting cluster of the directory on disk
    56 00000051 ????????????????    <1>     .qIFSPtr             dq ?   ;Reserved for IFS driver expansions
    57 00000059 ????????            <1>     .dNetStore           dd ?   ;For storing a owner dword for IFS (21h/5F03h)
    58 0000005D ????                <1>     .wBackslashOffset    dw ?   ;How many chars to skip for getting the path
    59                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    60                              <1> ; another, we save the number of chars to skip to that deep level).
    61                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    62                              <1> ; Only affects for SUBST drives, not JOIN
    63                              <1> ; Flags: Bit 15 set = Network drive
    64                              <1> ;        Bit 14 set = Physical drive
    65                              <1> ;        Bit 13 set = JOIN'ed drive
    66                              <1> ;        Bit 12 set = SUBST'ed drive
    67                              <1> ;        Bit 7  set = Redirected, not net. drive (This is how MSCDEX worked)
    68                              <1> endstruc
    69                              <1> ;CDS equates
    70                              <1> cdsRedirDrive   equ 8000h   ;All drives which use the Redirector interface
    71                              <1> cdsValidDrive   equ 4000h   ;CDS valid
    72                              <1> cdsJoinDrive    equ 2000h   ;CDS for joined drives
    73                              <1> cdsSubstDrive   equ 1000h   ;Drives formed by Subst
    74                              <1> cdsRdirLocDrive equ 0080h   ;Redirector but Local
    75                              <1> ;------------------------------------------------------------------------;
    76                              <1> ; The SFT is a way to allow applications to open file handles to files 
    77                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    78                              <1> ; under the first header, and then a second header will be linked to the 
    79                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    80                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    81                              <1> ; using the FCBS= command. Default FCBS=5.
    82                              <1> ;
    83                              <1> ; A file handle describes the file, and the location within the file that
    84                              <1> ; we are reading. The file handle can be manipulated without the file
    85                              <1> ; being in memory, thus allowing the user to access data without needing 
    86                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    87                              <1> ; accessing devices, by treating them as files with their drivers 
    88                              <1> ; responding and translating the manipulations of the file handle itself.
    89                              <1> ; Neither the driver nor the application should see or use the SFT for
    90                              <1> ; the handle, as it is subject to change (and will change when file 
    91                              <1> ; sharing provisions are included). The DOS will make requests to the 
    92                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    93                              <1> ; track of the information in the SFT entry for that handle. 
    94                              <1> ;
    95                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    96                              <1> ; can point to the same file. It all depends on what the applications 
    97                              <1> ; want to do with the File.
    98                              <1> ;
    99                              <1> ; !!!!IMPORTANT!!!!
   100                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   101                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   102                              <1> ;
   103                              <1> ;Each SFT may look like this:
   104                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   105                              <1> ;            |                |
   106                              <1> ;       wNumFiles*sft    wNumFiles*sft
   107                              <1> ;
   108                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   109                              <1> ; System FCBs.
   110                              <1> ;
   111                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   112                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   113                              <1> ;
   114                              <1> ; DEFAULT FILES=8, MINIMUM FILES=5
   115                              <1> ; DEFAULT FCBS=5,  MINIMUM FCBS=5
   116                              <1> ;------------------------------------------------------------------------;
   117                              <1> struc sfth   ;System file table header
   118                              <1> ; This is the SFT header.
   119                              <1> ; This structure comes before the start of the first file in the array/table.
   120 00000000 ????????????????    <1>     .qNextSFTPtr dq ?    ;Pointer to the next SFT
   121 00000008 ????                <1>     .wNumFiles   dw ?    ;Number of files in this table
   122                              <1> endstruc
   123                              <1> 
   124                              <1> struc sft
   125                              <1> ;This is the file struc itself
   126 00000000 ????                <1>     .wNumHandles dw ?    ;Number of handles pointing to this file
   127 00000002 ????                <1>     .wOpenMode   dw ?    ;File access permissions and behvaiours
   128 00000004 ??                  <1>     .bFileAttrib db ?    ;Regular File Attributes
   129 00000005 ????                <1>     .wDeviceInfo dw ?    ;Includes unit number if a block device
   130 00000007 ????????????????    <1>     .qPtr        dq ?    ;IF char, ptr to device driver header, ELSE DPBptr
   131 0000000F ????????            <1>     .dStartClust dd ?    ;Start cluster of file pointed to by SFT entry
   132 00000013 ????                <1>     .wTime       dw ?    ;File Time, updated on open and writes
   133 00000015 ????                <1>     .wDate       dw ?    ;File Date, updated on open and writes
   134 00000017 ????????            <1>     .dFileSize   dd ?    ;File Size, in bytes
   135 0000001B ????????            <1>     .dCurntOff   dd ?    ;Current Offset pointed to by SFT entry, in bytes
   136 0000001F ????????            <1>     .dRelClust   dd ?    ;Rel cluster pointed to by SFT entry
   137 00000023 ????????            <1>     .dAbsClusr   dd ?    ;Absolute cluster pointed to by SFT entry
   138 00000027 ????????????????    <1>     .qDirSect    dq ?    ;Abs number of sector containing directory entry 
   139 0000002F ??                  <1>     .bNumDirEnt  db ?    ;Directory entry within dir sector (byte offset/32)
   140 00000030 <res Bh>            <1>     .sFileName   db 11 dup (?)   ;8.3 Filename
   141 0000003B ????????????????    <1>     .qSharePtr   dq ?    ;SHARE pointer to previous SFT sharing same file
   142 00000043 ????                <1>     .wMachNum    dw ?    ;SHARE number of network machine opening file
   143 00000045 ????????????????    <1>     .qPSPOwner   dq ?    ;Addr of PSP of program which first opened this file
   144 0000004D ????                <1>     .wShareRec   dw ?    ;offset within SHARE code segment of sharing record
   145                              <1> ;                           0 means no record
   146                              <1> endstruc
   147                              <1> ;Open Mode equates
   148                              <1> ;Access modes   Bits[2:0]
   149                              <1> ReadAccess      equ 0h
   150                              <1> WriteAccess     equ 1h
   151                              <1> RWAccess        equ 2h
   152                              <1> ;Bit 3 reserved 0
   153                              <1> ;Sharing modes  Bits[6:4]
   154                              <1> CompatShare     equ 0h
   155                              <1> denyRWShare     equ 10h
   156                              <1> denyWriteShare  equ 20h
   157                              <1> denyReadShare   equ 30h
   158                              <1> denyNoneShare   equ 40h
   159                              <1> ;NetFCB is for files open by a local server, handling IO from a remote
   160                              <1> ; client by proxy opened by an FCB! Sets the Net bit to indicate this. 
   161                              <1> ;Thus, this is a handle with no JFT entry! Server handles its own JFT!
   162                              <1> netFCBShare     equ 70h     
   163                              <1> noInherit       equ 80h
   164                              <1> ;Bits 8-12 reserved 0
   165                              <1> ;Fancy open mode bits
   166                              <1> diskFullFail    equ 2000h   ;Reserved: If set, trigger Int 24h on disk full.
   167                              <1> noBufferWrites  equ 4000h   ;Reserved: If set, flush after each buffer write.
   168                              <1> ;Once share is loaded, if a local FCB open occurs, mark the sft as so.
   169                              <1> FCBopenedFile   equ 8000h   ;If set, file is opened by FCB, else handle based.
   170                              <1> 
   171                              <1> ;Attribute Byte
   172                              <1> readOnlyFile    equ 1h
   173                              <1> hiddenFile      equ 2h
   174                              <1> systemFile      equ 4h
   175                              <1> volLabelFile    equ 8h
   176                              <1> directoryFile   equ 10h ;Directory entry
   177                              <1> archiveFile     equ 20h
   178                              <1> charFile        equ 40h ;Reserved, never found in dir
   179                              <1> ;Device Info equates
   180                              <1> ;For a block device, bits [5:0] contain the drive number
   181                              <1> charDevConIn    equ 1h  ;If set, device is CON input
   182                              <1> charDevConOut   equ 2h  ;If set, device is CON output
   183                              <1> charDevNulDev   equ 4h  ;If set, device is NULL device
   184                              <1> charDevClockDev equ 8h  ;If set, device is CLOCK device
   185                              <1> charDevFastOut  equ 10h ;If set, device supports INT 29h
   186                              <1> charDevBinary   equ 20h ;If set, r/w char device in Binary mode!!!
   187                              <1> charDevNoEOF    equ 40h ;If set, no EOF when reading from device!!
   188                              <1> blokFileNoFlush equ 40h ;Set if file is synchronised with hard store!
   189                              <1> devCharDev      equ 80h ;If set, it is a char device!
   190                              <1> charDevNetSpool equ 800h    ;If set, device is a network spooler
   191                              <1> devNoInherit    equ 1000h   ;If set, handle not inherited by child processes
   192                              <1> charDevNamePipe equ 2000h   ;If set, device is a named pipe
   193                              <1> blokNoDTonClose equ 4000h   ;If set, dont update date and time when closing
   194                              <1> devRedirDev     equ 8000h   ;If set, dev/file is redirected!
   195                              <1>  
   196                              <1> ;------------------------------------------------------------------------;
   197                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   198                              <1> ; to an internal buffer, and then copying it to the specified location
   199                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   200                              <1> ; another request for the same sector from the same device is made, so 
   201                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   202                              <1> ; size, selected according to the largest detected sector size during 
   203                              <1> ; the initial loadup.
   204                              <1> ;
   205                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   206                              <1> ;
   207                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   208                              <1> ;------------------------------------------------------------------------;
   209                              <1> 
   210                              <1> struc bufferHdr
   211 00000000 ????????????????    <1>     .nextBufPtr  dq  ?   ;Pointer to the next buffer in the chain or -1 at end
   212                              <1>     .wDrvNumFlg:         ;Read as a word to get the following two bytes!
   213 00000008 ??                  <1>     .driveNumber db  ?   ;Drive number the buffer is used for (or -1 for free)
   214 00000009 ??                  <1>     .bufferFlags db  ?   ;Standard Flags
   215 0000000A ????????????????    <1>     .bufferLBA   dq  ?   ;LBA the buffer contains
   216 00000012 ??                  <1>     .bufFATcopy  db  ?   ;Number of copies of the FAT to write (1 if non-FAT)
   217 00000013 ????????            <1>     .bufFATsize  dd  ?   ;Number of sectors per FAT (or 0 if non-FAT)
   218 00000017 ????????????????    <1>     .driveDPBPtr dq  ?   ;Pointer to the device DPB block
   219 0000001F ??                  <1>     .reserved    db  ?   ;Alignment byte
   220                              <1>     .dataarea:             ;Points to the start of the data area
   221                              <1> endstruc
   222                              <1> ;Buffer Flag equates
   223                              <1> dosBuffer   equ 1h  ;Sector 0 (BPB/VPB) in buffer
   224                              <1> fatBuffer   equ 2h  ;FAT sector in buffer
   225                              <1> dirBuffer   equ 4h  ;Directory sector in buffer
   226                              <1> dataBuffer  equ 8h  ;File Data sector in buffer
   227                              <1> refBuffer   equ 20h ;Data in buffer has been referenced by an application
   228                              <1> dirtyBuffer equ 40h ;Data in buffer modified by an application
   229                              <1> freeBuffer  equ 00FFh   ;A word which goes into the drive number to clear both fields
   230                              <1> ;Note! A buffer is marked as referenced when the buffer is "obtained" by a syscall
   231                              <1> ;------------------------------------------------------------------------;
   232                              <1> ; Memory control block for each memory arena
   233                              <1> ;------------------------------------------------------------------------;
   234                              <1> struc mcb
   235 00000000 ??                  <1>     .marker     db ?  ;M = Member of the MCB chain. Z = Last member
   236 00000001 ????????????????    <1>     .owner      dq ?  ;Owning application PSP (para aligned) or 0 for free
   237 00000009 ????????            <1>     .blockSize  dd ?  ;Number of contiguous paragraphs owned by this block
   238                              <1>     ;The following byte is reserved outside of sysinit
   239 0000000D ??                  <1>     .subSysMark db ?  ;Marks the optional DOS subsystem of the MCB
   240 0000000E ????                <1>     .reserved   db 2 dup (?) 
   241                              <1>     .program:
   242                              <1> endstruc
   243                              <1> ;MCB equates
   244                              <1> mcbOwnerHole    equ 7   ;Owner = 7 => Memory hole, always fail free/realloc
   245                              <1> mcbOwnerFree    equ 0   ;Owner = 0 => Free and available space
   246                              <1> mcbOwnerDOS     equ 8   ;Owner = 8 => Owned by DOS
   247                              <1> mcbOwnerNewDOS  equ 9   ;Owner = 9 => New Kernel driver alloc. Needs setting to 8.
   248                              <1> mcbMarkCtn      equ "M"
   249                              <1> mcbMarkEnd      equ "Z"
   250                              <1> ;The following are used on MCB's that belong to DOS, that are not part of the
   251                              <1> ; main kernel (i.e. the CONFIG.SYS optional parts).
   252                              <1> mcbSubDriver    equ "D" ;Any memory allocated for a device driver's code.
   253                              <1> mcbSubDrvExtra  equ "L" ;Any memory allocated by a device driver.
   254                              <1> mcbSubDrvDPB    equ "P" ;Blocks used for DPB's are marked so.
   255                              <1> mcbSubIFS       equ "I" ;Unused for now
   256                              <1> mcbSubFiles     equ "F" ;Any memory allocated for Files.
   257                              <1> mcbSubFCBS      equ "X" ;Unused for now
   258                              <1> mcbSubBuffers   equ "B" ;Any memory allocated for Buffers.
   259                              <1> mcbSubCDS       equ "L" ;Any memory allocated to store a CDS.
   260                              <1> mcbSubStacks    equ "S" ;Unused for now
   261                              <1> 
   262                              <1> 
   263                              <1> memFirstFit     equ 0   ;First free block goes to application
   264                              <1> memBestFit      equ 1   ;Block whos size closest matches requirement
   265                              <1> memLastFit      equ 2   ;Last free block goes to application
   266                              <1> 
   267                              <1> ;Owner = Para aligned address => Owning application PSP
   268                              <1> ;...To consider...
   269                              <1> ;Owner = Non-para aligned address => Error? Should maybe lock up system?
   270                              <1> ;blockSize counts the number of paragraphs FROM .program TO THE NEXT MCB!
   271                              <1> ;------------------------------------------------------------------------;
   272                              <1> ; For Int 21h, the callers registers are saved on their stack in the 
   273                              <1> ; following order, thus allowing for return values to be placed in the 
   274                              <1> ; registers by accessing the caller register stack frame.
   275                              <1> ;------------------------------------------------------------------------;
   276                              <1> struc callerFrame
   277 00000000 ????????????????    <1>     .rax    dq ?  ;Bottom of frame, pointer to rax saved in oldRSP
   278 00000008 ????????????????    <1>     .rbx    dq ?    
   279 00000010 ????????????????    <1>     .rcx    dq ?
   280 00000018 ????????????????    <1>     .rdx    dq ?
   281 00000020 ????????????????    <1>     .rsi    dq ?
   282 00000028 ????????????????    <1>     .rdi    dq ?
   283 00000030 ????????????????    <1>     .rbp    dq ?
   284 00000038 ????????????????    <1>     .r8     dq ?  ;To be removed if truly not needed
   285 00000040 ????????????????    <1>     .r9     dq ?
   286                              <1> ;Pushed by Processor when invoked via Interrupt
   287 00000048 ????????????????    <1>     .rip    dq ?
   288 00000050 ????????????????    <1>     .cs     dq ?
   289 00000058 ????????????????    <1>     .flags  dq ?
   290                              <1> endstruc
   291                              <1> 
   292                              <1> struc dpl
   293                              <1> ;DOS parameter list, pointer to this stack is passed to DOS in rdx on
   294                              <1> ; server calls
   295 00000000 ????????????????    <1>     .rax    dq ?
   296 00000008 ????????????????    <1>     .rbx    dq ?
   297 00000010 ????????????????    <1>     .rcx    dq ?
   298 00000018 ????????????????    <1>     .rdx    dq ?
   299 00000020 ????????????????    <1>     .rsi    dq ?
   300 00000028 ????????????????    <1>     .rdi    dq ?
   301 00000030 ????????????????    <1>     .r8     dq ?
   302 00000038 ????????????????    <1>     .r9     dq ?
   303 00000040 ????????????????    <1>     .align  dq ?
   304 00000048 ????????????????    <1>     .compID dq ?  ;Computer id, low word used only
   305 00000050 ????????????????    <1>     .procID dq ?  ;Process ID
   306                              <1> endstruc
   307                              <1> 
   308                              <1> struc cfgFrame  ;Frame used for config.sys parsing
   309 00000000 ????????????????    <1>     .oldRBP         dq ?  ;Ptr to DOSSEG
   310 00000008 ????????????????    <1>     .newBuffers     dq ?  ;New buffers value
   311 00000010 ????????????????    <1>     .newSFTVal      dq ?
   312 00000018 ????????????????    <1>     .newFCBSVal     dq ?
   313 00000020 ????????????????    <1>     .newProtFCBSVal dq ?  ;Number of protected FCBS
   314 00000028 ????????????????    <1>     .newLastdrive   dq ?
   315 00000030 ????????????????    <1>     .newStacks      dq ?  ;Ignored for now
   316 00000038 ????????????????    <1>     .newStackSize   dq ?  ;Ignored for now
   317 00000040 ????????????????    <1>     .cfgHandle      dq ?  ;CONFIG.SYS handle
   318 00000048 ????????????????    <1>     .lastLine       dq ?  ;Set if the last line is current
   319 00000050 ????????????????    <1>     .linePtr        dq ?  ;Ptr to line buffer of line being processed
   320 00000058 ????????????????    <1>     .driverBreak    dq ?  ;Ptr to the pathname terminator 
   321 00000060 ????????????????    <1>     .breakChar      dq ?  ;Char that was replaced by null for terminator
   322                              <1> endstruc
   323                              <1> 
   324                              <1> struc filename
   325                              <1> ;8.3 File name struct
   326 00000000 ????????????????    <1>     .fName  db 8 dup (?)
   327 00000008 ??????              <1>     .fExt   db 3 dup (?)
   328                              <1> endstruc
   329                              <1> 
   330                              <1> struc ffBlock   ;The structure of the Find First structure at the DTA
   331 00000000 ??                  <1>     .driveNum   db ?  ;Drive we are searching on, 1 based number
   332 00000001 <res Bh>            <1>     .template   db 11 dup (?) ;Search template (? meaning anything)
   333 0000000C ??                  <1>     .attrib     db ?  ;Search attribute
   334 0000000D ????????            <1>     .dirOffset  dd ?  ;32 byte entry within dir cluster
   335 00000011 ????????            <1>     .parDirClus dd ?  ;Parent Directory Cluster number
   336 00000015 ??                  <1>     .attribFnd  db ?  ;Attrib of file found
   337 00000016 ????                <1>     .fileTime   dw ?  ;File time
   338 00000018 ????                <1>     .fileDate   dw ?  ;File date
   339 0000001A ????????            <1>     .fileSize   dd ?  ;Number of bytes
   340 0000001E <res Dh>            <1>     .asciizName db 13 dup (?) ;ASCIIZ name with dot and terminating nul
   341                              <1> endstruc
   342                              <1> 
   343                              <1> 
   344                              <1> dfltJFTsize equ 20  ;Default size of PSP JFT
   345                              <1> struc psp
   346 00000000 ????                <1>     .return     db 2 dup (?)  ;Should always be CDh 20h, same place as DOS
   347 00000002 ????????            <1>     .allocSize  dd ?  ;Number of paras in init alloc or when exiting as TSR.
   348 00000006 ????????            <1>                 dd ?  ;Reserved 4 bytes
   349 0000000A ????????????????    <1>     .oldInt22h  dq ?  ;Int 22h pointer on overlay load
   350 00000012 ????????????????    <1>     .oldInt23h  dq ?  ;Int 23h pointer on overlay load
   351 0000001A ????????????????    <1>     .oldInt24h  dq ?  ;Int 24h pointer on overlay load
   352 00000022 ????????????????    <1>     .parentPtr  dq ?  ;Pointer to parent process PSP
   353                              <1> ;If jftSize > 20, then the QWORD at .jobFileTbl becomes a pointer
   354                              <1> ; to the actual in use JFT and the other 12 bytes are left undefined.
   355                              <1> ;If jftSize < 20 (DOS will never set it so), then it is considered as 20
   356                              <1> ;If the user tries to reduce handle count to 20 or less, then the PSP JFT is 
   357                              <1> ; always used and jftSize.
   358                              <1>     .externalJFTPtr:    ;Ptr to external JFT array (first byte AFTER MCB)
   359 0000002A <res 14h>           <1>     .jobFileTbl db dfltJFTsize dup (?) ;Main File handle array, JFT
   360 0000003E ????????????????    <1>     .envPtr     dq ?  ;Pointer to the environment
   361 00000046 ????????????????    <1>     .rspPtr     dq ?  ;Pointer to rsp on entry to Int 21h
   362 0000004E ????                <1>     .jftSize    dw ?  ;JFT array size, 20 => PSP JFT in use
   363 00000050 ??????              <1>     .unixEntry  db 3 dup (?)  ;Must always be CDh 21h CBh, same place as DOS
   364 00000053 ????????????????    <1>     .prevPSP    dq ?  ;Pointer to the previous PSP in chain (used by SHARE)
   365 0000005B ??                  <1>                 db ?  ;Reserved byte
   366                              <1> ;The below are in the same place as in DOS.
   367                              <1>     .cmdLineArgPtr: ;Symbol for future use
   368 0000005C <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1 
   369 0000006C <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
   370                              <1>     .dta:   ;Pointer to the default DTA in the PSP
   371 00000080 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
   372 00000081 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
   373                              <1> endstruc
   374                              <1> 
   375                              <1> struc clkStruc
   376 00000000 ????                <1>     .dateWord   dw ?
   377 00000002 ??                  <1>     .minutes    db ?
   378 00000003 ??                  <1>     .hours      db ?
   379 00000004 ??                  <1>     .hseconds   db ?  ;Hundreths of seconds
   380 00000005 ??                  <1>     .seconds    db ?
   381                              <1> endstruc
   382                              <1> 
   383                              <1> 
   384                              <1> struc extCtryStruc
   385 00000000 ??                  <1>     .infoIDCode db ?    ;Information ID code (01h)
   386 00000001 ????                <1>     .strucSize  dw ?    ;Length of the structure  (42 or less)
   387 00000003 ????                <1>     .ctryID     dw ?    ;Country ID number
   388 00000005 ????                <1>     .cpNumber   dw ?    ;Code page number
   389 00000007 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   390                              <1>                         ;0 = month day year hh:mm:ss
   391                              <1>                         ;1 = day month year hh:mm:ss
   392                              <1>                         ;2 = year month day hh:mm:ss
   393 00000009 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   394 0000000E ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   395 00000010 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   396 00000012 ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   397 00000014 ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   398 00000016 ??                  <1>     .currFmt    db ?    ;Currency Format
   399                              <1>                         ;0 = Symbol leads, without space
   400                              <1>                         ;1 = Symbol follows, without space
   401                              <1>                         ;2 = Symbol leads, one space
   402                              <1>                         ;3 = Symbol follows, one space
   403                              <1>                         ;4 = Symbol replace decimal separator
   404 00000017 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   405 00000018 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   406 00000019 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   407 00000021 ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   408 00000023 <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   409                              <1> endstruc
   410                              <1> 
   411                              <1> struc countryStruc
   412 00000000 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   413                              <1>                         ;0 = month day year hh:mm:ss
   414                              <1>                         ;1 = day month year hh:mm:ss
   415                              <1>                         ;2 = year month day hh:mm:ss
   416 00000002 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   417 00000007 ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   418 00000009 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   419 0000000B ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   420 0000000D ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   421 0000000F ??                  <1>     .currFmt    db ?    ;Currency Format
   422                              <1>                         ;0 = Symbol leads, without space
   423                              <1>                         ;1 = Symbol follows, without space
   424                              <1>                         ;2 = Symbol leads, one space
   425                              <1>                         ;3 = Symbol follows, one space
   426                              <1>                         ;4 = Symbol replace decimal separator
   427 00000010 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   428 00000011 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   429 00000012 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   430 0000001A ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   431 0000001C <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   432                              <1> endstruc
   433                              <1> 
   434                              <1> ;Critical Error AH bitfield equates
   435                              <1> critRead    equ 0h
   436                              <1> critWrite   equ 1h
   437                              <1> critDOS     equ 0h
   438                              <1> critFAT     equ 2h
   439                              <1> critDir     equ 4h
   440                              <1> critData    equ 6h
   441                              <1> critFailOK  equ 8h
   442                              <1> critRetryOK equ 10h
   443                              <1> critIgnorOK equ 20h
   444                              <1> critCharDev equ 80h
   445                              <1> 
   446                              <1> critIgnore  equ 0
   447                              <1> critRetry   equ 1
   448                              <1> critAbort   equ 2
   449                              <1> critFail    equ 3
   450                              <1> 
   451                              <1> ;MISC ASCII control chars
   452                              <1> NUL equ 00h ;^@         | ASCII Null
   453                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text) 
   454                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
   455                              <1> BEL equ 07h ;^G         | ASCII Bell
   456                              <1> BSP equ 08h ;^H         | ASCII Backspace
   457                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
   458                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
   459                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
   460                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
   461                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
   462                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
   463                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
   464                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
   465                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
   466                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
   467                              <1> SPC equ 20h ;Printable  | ASCII Space
   468                              <1> ;This last one is NEVER printed with a caret as it is a console control char
   469                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
   470                              <1> 
   471                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
   472                              <1> ;Extended Ascii Codes
   473                              <1> eF1     equ 3Bh ;F1 second byte
   474                              <1> eF2     equ 3Ch ;F2 second byte
   475                              <1> eF3     equ 3Dh ;F3 second byte
   476                              <1> eF4     equ 3Eh ;F4 second byte
   477                              <1> eF5     equ 3Fh ;F5 second byte
   478                              <1> eF6     equ 40h ;F6 second byte
   479                              <1> eF7     equ 41h ;F7 second byte
   480                              <1> eCursL  equ 4Bh ;Cursor Left second byte
   481                              <1> eCursR  equ 4Dh ;Cursor Right second byte
   482                              <1> eIns    equ 52h ;Insert second byte
   483                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
   484                              <1> 
   485                              <1> ;Default Configuration for the system
   486                              <1> 
   487                              <1> buffersDefault  equ 30
   488                              <1> filesDefault    equ 20
   489                              <1> fcbsDefault     equ 4
   490                              <1> safeFcbsDeflt   equ 0
   491                              <1> lastDriveDeflt  equ 5   
   492                              <1> 
   493                              <1> ;ASCII char property table equates. If such a bit is clear in signature in table
   494                              <1> ; then the char has this property.
   495                              <1> badChar     equ 1   ;Bad ASCIIZ filename char
   496                              <1> termChar    equ 2   ;Terminator char type
   497                              <1> sepChar     equ 4   ;Separator char type
   498                              <1> badFCBChar  equ 8   ;FCB filename char
    17                                  %include "./inc/dosError.inc"
     1                              <1> ;DOS Error codes
     2                              <1> 
     3                              <1> ;Extended Error Codes
     4                              <1> errInvFnc   equ 1   ;Invalid function number
     5                              <1> errFnf      equ 2   ;File not found
     6                              <1> errPnf      equ 3   ;Path not found
     7                              <1> errNhl      equ 4   ;Too many open handles, no handles left
     8                              <1> errAccDen   equ 5   ;Access denied (to resource)
     9                              <1> errBadHdl   equ 6   ;Invalid handle
    10                              <1> errMCBbad   equ 7   ;MCB's destroyed
    11                              <1> errNoMem    equ 8   ;Insufficient memory
    12                              <1> errMemAddr  equ 9   ;Invalid Memory Block Address
    13                              <1> errBadEnv   equ 10  ;Invalid environment
    14                              <1> errBadFmt   equ 11  ;Invalid format (path etc)
    15                              <1> errAccCde   equ 12  ;Invalid Access Code    ?
    16                              <1> errInvDat   equ 13  ;Invalid data
    17                              <1> ;           equ 14  ;Reserved
    18                              <1> errBadDrv   equ 15  ;Invalid drive specified
    19                              <1> errDelCD    equ 16  ;Attempt to delete the current directory
    20                              <1> errDevUnk   equ 17  ;Not the same device (Device Unknown)
    21                              <1> errNoFil    equ 18  ;No more files, no match found
    22                              <1> ;The following are Driver error codes + 19
    23                              <1> drvErrShft  equ 19  ;Used to shift Driver error codes to extended error codes
    24                              <1> errWpd      equ 19  ;Attempt to write on write protected disk
    25                              <1> errUnkUnt   equ 20  ;Unknown Unit
    26                              <1> errDrvNR    equ 21  ;Drive not ready
    27                              <1> errUnkCmd   equ 22  ;Unknown Command
    28                              <1> errCRCerr   equ 23  ;Data (CRC) error
    29                              <1> errBadRLn   equ 24  ;Bad request structure length
    30                              <1> errSekErr   equ 25  ;Seek error
    31                              <1> errUnkMed   equ 26  ;Unknown media type
    32                              <1> errSecNF    equ 27  ;Sector not Found
    33                              <1> errNoPap    equ 28  ;Printer out of paper
    34                              <1> errWF       equ 29  ;Write fault
    35                              <1> errRF       equ 30  ;Read fault
    36                              <1> errGF       equ 31  ;General fault
    37                              <1> ;----------------------------------------------
    38                              <1> ;The following two go inbetween the Disk errors
    39                              <1> errShrVio   equ 32  ;Sharing violations
    40                              <1> errLokVio   equ 33  ;File Lock violation
    41                              <1> ;----------------------------------------------
    42                              <1> errIDC      equ 34  ;Driver code, Invalid Disk Change
    43                              <1> errNoFCB    equ 35  ;FCB unavailable
    44                              <1> errShrFul   equ 36  ;Sharing buffer full
    45                              <1> 
    46                              <1> errNoNet    equ 50  ;Network request not supported, generic net fail
    47                              <1> 
    48                              <1> errFilExist equ 80  ;File already exists
    49                              <1> errDirExist equ 82  ;Directory already exists
    50                              <1> errFI44     equ 83  ;Fail on Int 24h
    51                              <1> errRedir    equ 84  ;Too many levels of redirection
    52                              <1> errDupRedir equ 85  ;Trying to redirect a redirection
    53                              <1> errBadPass  equ 86  ;Bad password
    54                              <1> errBadParam equ 87  ;Bad parameter passed to request
    55                              <1> errNetWrite equ 88  ;Network Write Fault
    56                              <1> ;-----------------------------------------------------------------------------
    57                              <1> ;Error Loci
    58                              <1> eLocUnk     equ 1   ;Unknown locus, nonspecific or not appropriate
    59                              <1> eLocDsk     equ 2   ;Disk, related to Random Access to a disk or block device
    60                              <1> eLocNet     equ 3   ;Network related issues, shouldnt affect us (yet!)
    61                              <1> eLocChr     equ 4   ;Serial/Character Device error
    62                              <1> eLocMem     equ 5   ;Related to RAM
    63                              <1> ;-----------------------------------------------------------------------------
    64                              <1> ;Error Actions
    65                              <1> eActRet     equ 1   ;Retry
    66                              <1> eActDRet    equ 2   ;Delay then retry (Try again later)
    67                              <1> eActUsr     equ 3   ;Ask user to re-input data, i.e. bad filename or something
    68                              <1> eActAbt     equ 4   ;Abort with cleanup
    69                              <1> eActKil     equ 5   ;Abort without cleanup
    70                              <1> eActIgn     equ 6   ;Ignore error
    71                              <1> eActRetUsr  equ 7   ;Retry after user intervention (i.e swap remdev)
    72                              <1> ;-----------------------------------------------------------------------------
    73                              <1> ;Error classes
    74                              <1> eClsOoR     equ 1   ;Out of resources, no mem or handles
    75                              <1> eClsTS      equ 2   ;Temp sitch, should go away
    76                              <1> eClsAuth    equ 3   ;Authorisation, e.g. file permission error 
    77                              <1> eClsInt     equ 4   ;Internal DOS error or bug
    78                              <1> eClsHrdFlt  equ 5   ;Hardware Failure
    79                              <1> eClsSysFlt  equ 6   ;System Failure, i.e. missing or bad cfg files
    80                              <1> eClsAppFlt  equ 7   ;Application Program error, inconsistent requests etc...
    81                              <1> eClsNotFnd  equ 8   ;Resource not found (such as free SFT entry etc...)
    82                              <1> eClsBadFmt  equ 9   ;Bad format for resource
    83                              <1> eClsLocked  equ 10  ;Resource Locked
    84                              <1> eClsMedia   equ 11  ;Error is on medium, i.e. wrong or damaged remdev
    85                              <1> eClsClash   equ 12  ;Resource already exists!
    86                              <1> eClsUnk     equ 13  ;Unknown class
    18                                  %include "./inc/dosVars.inc"
     1                              <1> struc sysVars
     2 00000000 ????????????????    <1>     .dpbHeadPtr  dq ?    ;Pointer to the first DPB in the DPB chain x
     3 00000008 ????????????????    <1>     .sftHeadPtr  dq ?    ;Pointer to the first SFT header in SFT chain
     4 00000010 ????????????????    <1>     .clockPtr    dq ?    ;Pointer to the current active CLOCK$ device header x
     5                              <1>     ;                    The last driver loaded with the CLOCK$ bit[3] set 
     6 00000018 ????????????????    <1>     .vConPtr     dq ?    ;Ptr to the devdrv of the char dev controlling vCon x
     7                              <1>     ;                    The last driver loaded with the STDIN bit[0] set
     8 00000020 ????                <1>     .maxBytesSec dw ?    ;Maximum number of bytes per sector (size of buffers)x
     9 00000022 ????????????????    <1>     .bufHeadPtr  dq ?    ;Pointer to the head of the disk buffer chain x
    10 0000002A ????????????????    <1>     .cdsHeadPtr  dq ?    ;Pointer to the head of the CDS array x
    11 00000032 ????????????????    <1>     .fcbsHeadPtr dq ?    ;Pointer to the head of the System FCB chain
    12 0000003A ????                <1>     .numSafeSFCB dw ?    ;Number of protected FCBs (y in FCBS=x,y)
    13 0000003C ??                  <1>     .numPhysVol  db ?    ;Number of physical volumes in the system x
    14 0000003D ??                  <1>     .lastdrvNum  db ?    ;Value of LASTDRIVE (default = 5) [Size of CDS array]x
    15 0000003E ??                  <1>     .numBuffers  db ?    ;Buffers=30 default
    16 0000003F <res 22h>           <1>     .nulDevHdr   db 22h dup (?)
    17 00000061 ??                  <1>     .numJoinDrv  db ?    ;Number of Joined Drives
    18                              <1> endstruc
    19                                  %include "./src/main.asm"
     1                              <1> ;Subst main routine
     2                              <1> startMain:
     3 00000000 EB01                <1>     jmp short .cVersion
     4 00000002 01                  <1> .vNum:  db 1
     5                              <1> .cVersion:
     6 00000003 488D25(80010000)    <1>     lea rsp, endOfAlloc   ;Move RSP to our internal stack
     7                              <1> ;Do a version check since this version cannot check the number of rows/cols
     8 0000000A FC                  <1>     cld
     9 0000000B B800300000          <1>     mov eax, 3000h
    10 00000010 CD21                <1>     int 21h
    11 00000012 3A05EAFFFFFF        <1>     cmp al, byte [.vNum]    ;Version number 1 check
    12 00000018 7615                <1>     jbe short okVersion
    13 0000001A 488D15AC020000      <1>     lea rdx, badVerStr
    14                              <1> badPrintExit:
    15 00000021 B800090000          <1>     mov eax, 0900h
    16 00000026 CD21                <1>     int 21h
    17 00000028 B8FF4C0000          <1>     mov eax, 4CFFh
    18 0000002D CD21                <1>     int 21h
    19                              <1> okVersion:
    20 0000002F 488D25(80010000)    <1>     lea rsp, endOfAlloc   ;Move RSP to our internal stack
    21                              <1> ;Now let us resize ourselves so as to take up as little memory as possible
    22 00000036 BB[80010000]        <1>     mov ebx, endOfAlloc
    23 0000003B B8004A0000          <1>     mov eax, 4A00h
    24 00000040 CD21                <1>     int 21h ;If this fails, we still proceed as we are just being polite!
    25                              <1> ;Now get the sysvars pointer and save it in var.
    26                              <1> ;This cannot change so it is fine to do it out of a critical section.
    27 00000042 B800520000          <1>     mov eax, 5200h
    28 00000047 CD21                <1>     int 21h
    29 00000049 48891D(00000000)    <1>     mov qword [pSysvars], rbx
    30                              <1> parseCmdLine:
    31                              <1> ;Now parse the command line
    32 00000050 498DB081000000      <1>     lea rsi, qword [r8 + psp.progTail]
    33 00000057 31C9                <1>     xor ecx, ecx    ;Keep a count of vars on cmd line in ecx
    34 00000059 31C0                <1>     xor eax, eax    ;Clear all upper bytes for fun
    35 0000005B 488905(08000000)    <1>     mov qword [pVar1], rax  ;Init these vars
    36 00000062 488905(10000000)    <1>     mov qword [pVar2], rax
    37 00000069 E830020000          <1>     call skipDelims ;Goto the first non-delimiter char
    38 0000006E 3C0D                <1>     cmp al, CR
    39 00000070 7435                <1>     je endParse
    40 00000072 488935(08000000)    <1>     mov qword [pVar1], rsi    ;Save the ptr to the first var
    41 00000079 FFC1                <1>     inc ecx
    42 0000007B E82A020000          <1>     call findDelimOrCR
    43 00000080 3C0D                <1>     cmp al, CR
    44 00000082 7423                <1>     je endParse
    45 00000084 E815020000          <1>     call skipDelims
    46 00000089 488935(10000000)    <1>     mov qword [pVar2], rsi    ;Save the ptr to the second var
    47 00000090 FFC1                <1>     inc ecx
    48 00000092 E813020000          <1>     call findDelimOrCR
    49 00000097 3C0D                <1>     cmp al, CR  ;The second arg shouldve been the last arg
    50 00000099 740C                <1>     je endParse
    51                              <1> badParmExit:
    52 0000009B 488D1541020000      <1>     lea rdx, badParmStr
    53 000000A2 E97AFFFFFF          <1>     jmp badPrintExit
    54                              <1> endParse:
    55 000000A7 85C9                <1>     test ecx, ecx
    56 000000A9 0F844D010000        <1>     jz printSubst   ;If no arguments found, print the substs!
    57 000000AF 81F901000000        <1>     cmp ecx, 1      
    58 000000B5 74E4                <1>     je badParmExit  ;Cannot have just 1 argument on the cmdline
    59 000000B7 B800370000          <1>     mov eax, 3700h  ;Get switchchar in dl
    60 000000BC CD21                <1>     int 21h
    61 000000BE 31C9                <1>     xor ecx, ecx    ;Use as cntr (1 or 2) to indicate which var has ptr to /D
    62 000000C0 488B35(08000000)    <1>     mov rsi, qword [pVar1]
    63 000000C7 3816                <1>     cmp byte [rsi], dl
    64 000000C9 7509                <1>     jne .g2
    65 000000CB E899010000          <1>     call checkSwitchOk  ;Now check rsi points to a bona fide /D 
    66 000000D0 72C9                <1>     jc badParmExit
    67 000000D2 FFC1                <1>     inc ecx
    68                              <1> .g2:
    69 000000D4 488B35(10000000)    <1>     mov rsi, qword [pVar2]
    70 000000DB 3817                <1>     cmp byte [rdi], dl
    71 000000DD 7510                <1>     jne .switchDone
    72 000000DF 85C9                <1>     test ecx, ecx   ;Var2 can be /D ONLY IF Var1 was not /D
    73 000000E1 75B8                <1>     jnz badParmExit
    74 000000E3 E881010000          <1>     call checkSwitchOk  ;Now check rsi points to a bona fide /D 
    75 000000E8 72B1                <1>     jc badParmExit
    76 000000EA B902000000          <1>     mov ecx, 2      ;Else, indicate var2 has the /D flag!
    77                              <1> .switchDone:
    78 000000EF 85C9                <1>     test ecx, ecx   ;If ecx is zero, then we are adding a subst.
    79 000000F1 0F84D4000000        <1>     jz addSubst
    80                              <1> ;Else we are deleting a subst drive.
    81                              <1> delSubst:
    82 000000F7 488B35(08000000)    <1>     mov rsi, qword [pVar1]
    83 000000FE 488B3D(10000000)    <1>     mov rdi, qword [pVar2]
    84 00000105 81F901000000        <1>     cmp ecx, 1          ;If ecx = 1, rsi points to the /D
    85 0000010B 480F45FE            <1>     cmovne rdi, rsi     ;Make rdi point to the drive letter!
    86                              <1> ;rdi points to the drive letter in cmdline. Check it is legit.
    87 0000010F 8A4702              <1>     mov al, byte [rdi + 2]
    88 00000112 E8A3010000          <1>     call isALDelim
    89 00000117 7582                <1>     jne badParmExit
    90 00000119 807F013A            <1>     cmp byte [rdi + 1], ":"
    91 0000011D 0F8578FFFFFF        <1>     jne badParmExit
    92                              <1> ;Here the char is legit! Now UC it and use it as offset into CDS
    93                              <1> ; to deactivate it!
    94 00000123 0FB607              <1>     movzx eax, byte [rdi]
    95 00000126 50                  <1>     push rax
    96 00000127 B813120000          <1>     mov eax, 1213h  ;UC char
    97 0000012C CD2F                <1>     int 2Fh
    98 0000012E 0FB6C8              <1>     movzx ecx, al   ;Move the UC char into ecx
    99 00000131 58                  <1>     pop rax         ;Rebalance the stack
   100 00000132 81E941000000        <1>     sub ecx, "A"    ;Turn into an offset into CDS
   101                              <1> ;Check if we are deleting the current drive.
   102 00000138 B800190000          <1>     mov eax, 1900h  ;Get current drive
   103 0000013D CD21                <1>     int 21h
   104 0000013F 38C8                <1>     cmp al, cl  ;If we are deleting the current drive, error exit!
   105 00000141 0F8454FFFFFF        <1>     je badParmExit
   106                              <1> ;Check if the subst drive we want to deactivate is a valid drive
   107                              <1> ; in our system (i.e. does such a drive entry exist in the CDS array)
   108 00000147 E83E010000          <1>     call enterDOSCrit   ;Enter crit, Exit in the exit routine!
   109 0000014C 488B1D(00000000)    <1>     mov rbx, qword [pSysvars]   
   110 00000153 0FB6433D            <1>     movzx eax, byte [rbx + sysVars.lastdrvNum]
   111 00000157 38C1                <1>     cmp cl, al  ;If drive specified is past end of CDS array, error!
   112 00000159 7766                <1>     ja .error
   113                              <1> ;Point rdi to the cds we are adjusting.
   114 0000015B 488D7B2A            <1>     lea rdi, qword [rbx + sysVars.cdsHeadPtr]   ;Point rdi to cds array
   115 0000015F B85F000000          <1>     mov eax, cds_size
   116 00000164 F7E1                <1>     mul ecx
   117 00000166 81C141000000        <1>     add ecx, "A"    ;Turn offset back into a UC drive letter!
   118 0000016C 4801C7              <1>     add rdi, rax    ;rdi now points to the right CDS
   119                              <1> ;Check the cds we have chosen is really a subst drive
   120 0000016F 66F747430010        <1>     test word [rdi + cds.wFlags], cdsSubstDrive
   121 00000175 754A                <1>     jne .error      ;If this CDS is not a subst drive, error!
   122                              <1> ;Start editing the CDS back to it's default state
   123 00000177 880F                <1>     mov byte [rdi], cl  ;Place the drive letter...
   124 00000179 66C747025C00        <1>     mov word [rdi + 2], "\"   ;... and root backslash with null terminator!
   125 0000017F C6475D02            <1>     mov byte [rdi + cds.wBackslashOffset], 2    ;Go to root!
   126 00000183 C7474D00000000      <1>     mov dword [rdi + cds.dStartCluster], 0      ;Set start cluster for root!
   127                              <1> ;Deactivate the subst but also the drive possibly temporarily!
   128 0000018A 66816743FFAF        <1>     and word [rdi + cds.wFlags], ~(cdsSubstDrive | cdsValidDrive)
   129                              <1> ;Check for a physical DPB for this drive letter.
   130                              <1> ;I.E if drive D selected, search for the fourth DPB.
   131 00000190 81E941000000        <1>     sub ecx, "A"    ;Turn ecx back into a 0 based drive number
   132                              <1> ;If the drive number is above the number of physical drives, we 
   133                              <1> ; ignore the search as the physical drives always populate the 
   134                              <1> ; first drives. Acts as a minor optimisation to avoid walking DPB linked list.
   135 00000196 3A4B3C              <1>     cmp cl, byte [rbx + sysVars.numPhysVol]
   136 00000199 7715                <1>     ja .exit    ;If drv num > physical drvs, we ignore this search!
   137                              <1> ;Search the DPB linked list for the drive number associated to this drive!
   138 0000019B 488B2B              <1>     mov rbp, qword [rbx + sysVars.dpbHeadPtr]
   139                              <1> .lp:
   140 0000019E 384D00              <1>     cmp byte [rbp + dpb.bDriveNumber], cl
   141 000001A1 7412                <1>     je .dpbFnd  ;If DPB found for the drive in cl, 
   142 000001A3 488B6D25            <1>     mov rbp, qword [rbp + dpb.qNextDPBPtr]
   143 000001A7 4881FDFFFFFFFF      <1>     cmp rbp, -1 ;We should never fall through but still better to be safe!
   144 000001AE 75EE                <1>     jne .lp
   145                              <1> .exit:
   146 000001B0 E9A8000000          <1>     jmp exit
   147                              <1> .dpbFnd:
   148 000001B5 48896F45            <1>     mov qword [rdi + cds.qDPBPtr], rbp  ;Set this DPB as the CDS DPB!
   149 000001B9 66814F430040        <1>     or word [rdi + cds.wFlags], cdsValidDrive   ;Reactivate this drive!
   150 000001BF EBEF                <1>     jmp short .exit
   151                              <1> .error:
   152                              <1> ;Invalid drive specified!
   153 000001C1 E8CE000000          <1>     call exitDOSCrit    ;Exit the critical section before exiting!!
   154 000001C6 E9D0FEFFFF          <1>     jmp badParmExit
   155                              <1>     
   156                              <1> addSubst:
   157                              <1> ;Here we add the subst path. We gotta check that path provided
   158                              <1> ; exists! It is not null terminated so we gotta null terminate it.
   159                              <1> ; We also gotta get rid of any trailing slashes from the path provided!
   160                              <1> ;
   161                              <1> ;Drive1 can be valid, be cannot be a subst, join or net drive!
   162                              <1> ;
   163 000001CB 488B35(08000000)    <1>     mov rsi, qword [pVar1]
   164 000001D2 31C9                <1>     xor ecx, ecx
   165                              <1> 
   166 000001D4 488D1509000000      <1>     lea rdx, .msg
   167 000001DB B800090000          <1>     mov eax, 0900h
   168 000001E0 CD21                <1>     int 21h
   169 000001E2 CD20                <1>     int 20h
   170 000001E4 554E494D504C454D45- <1> .msg: db "UNIMPLEMENTED EXCEPTION$"
   170 000001ED 4E5445442045584345- <1>
   170 000001F6 5054494F4E24        <1>
   171                              <1> 
   172                              <1> printSubst:
   173 000001FC E889000000          <1>     call enterDOSCrit   ;Ensure the CDS size and ptr doesnt change
   174 00000201 488B1D(00000000)    <1>     mov rbx, qword [pSysvars]
   175 00000208 488D7B2A            <1>     lea rdi, qword [rbx + sysVars.cdsHeadPtr]
   176 0000020C 0FB64B3D            <1>     movzx ecx, byte [rbx + sysVars.lastdrvNum]  ;Get # of CDS's
   177 00000210 BB41000000          <1>     mov ebx, "A"    
   178                              <1> .lp:
   179 00000215 66F747430010        <1>     test word [rdi + cds.wFlags], cdsSubstDrive
   180 0000021B 7433                <1>     jz .gotoNextCDS
   181                              <1> ;Print the CDS drive letter and the rocket
   182 0000021D 488D15E0000000      <1>     lea rdx, substStr
   183 00000224 881A                <1>     mov byte [rdx], bl  ;Overwrite the drive letter in substStr
   184 00000226 B800090000          <1>     mov eax, 0900h      ;Print the substStr
   185 0000022B CD21                <1>     int 21h
   186                              <1> ;Print the current path of the cds upto the backslash offset
   187 0000022D 53                  <1>     push rbx
   188 0000022E 0FB74F5D            <1>     movzx ecx, word [rdi + cds.wBackslashOffset]
   189 00000232 488D17              <1>     lea rdx, qword [rdi + cds.sCurrentPath]
   190 00000235 BB01000000          <1>     mov ebx, 1          ;Print to STDOUT
   191 0000023A B800400000          <1>     mov eax, 4000h
   192 0000023F CD21                <1>     int 21h
   193 00000241 5B                  <1>     pop rbx
   194                              <1> ;Print a CRLF
   195 00000242 488D1597000000      <1>     lea rdx, crlf
   196 00000249 B800090000          <1>     mov eax, 0900h
   197 0000024E CD21                <1>     int 21h
   198                              <1> .gotoNextCDS:
   199 00000250 4881C75F000000      <1>     add rdi, cds_size
   200 00000257 FFC3                <1>     inc ebx ;Goto next drive letter!
   201 00000259 FFC9                <1>     dec ecx
   202 0000025B 75B8                <1>     jnz .lp
   203                              <1> exit:
   204 0000025D E832000000          <1>     call exitDOSCrit
   205 00000262 B8004C0000          <1>     mov eax, 4C00h
   206 00000267 CD21                <1>     int 21h
   207                              <1> 
   208                              <1> ;------------------------------------------------------------------------
   209                              <1> ; Utility functions below!
   210                              <1> ;------------------------------------------------------------------------
   211                              <1> checkSwitchOk:
   212                              <1> ;Checks if the switch char is D and if the char following is a 
   213                              <1> ; delimiter or CR. 
   214                              <1> ;Input: rsi -> Possible /D. Points to the /
   215                              <1> ;Output: CF=CY: Not ok to proceed.
   216                              <1> ;        CF=NC: Ok to proceed
   217 00000269 8A4601              <1>     mov al, byte [rsi + 1]
   218 0000026C 50                  <1>     push rax
   219 0000026D B813120000          <1>     mov eax, 1213h  ;UC char
   220 00000272 CD2F                <1>     int 2Fh
   221 00000274 3C44                <1>     cmp al, "D"
   222 00000276 58                  <1>     pop rax
   223 00000277 750F                <1>     jne .bad
   224 00000279 8A4602              <1>     mov al, byte [rsi + 2]
   225 0000027C 3C0D                <1>     cmp al, CR  ;If equal, clears CF
   226                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26                              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34 0000027E 7501                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 00000280 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3>  %endif
   227 00000281 E834000000          <1>     call isALDelim  ;If return equal, we are ok!
   228                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000286 74(80)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   229                              <1> .bad:
   230 00000288 F9                  <1>     stc
   231                              <1>     return
    13                              <2> %%_ret:
    14 00000289 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   232                              <1> 
   233                              <1> enterDOSCrit:
   234 0000028A 50                  <1>     push rax
   235 0000028B B801800000          <1>     mov eax, 8001h
   236 00000290 CD2A                <1>     int 2Ah
   237 00000292 58                  <1>     pop rax
   238                              <1>     return 
    13                              <2> %%_ret:
    14 00000293 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   239                              <1> 
   240                              <1> exitDOSCrit:
   241 00000294 50                  <1>     push rax
   242 00000295 B801810000          <1>     mov eax, 8101h
   243 0000029A CD2A                <1>     int 2Ah
   244 0000029C 58                  <1>     pop rax
   245                              <1>     return 
    13                              <2> %%_ret:
    14 0000029D C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   246                              <1> 
   247                              <1> skipDelims:
   248                              <1> ;Points rsi to the first non-delimiter char in a string, loads al with value
   249 0000029E AC                  <1>     lodsb
   250 0000029F E816000000          <1>     call isALDelim
   251 000002A4 74F8                <1>     jz skipDelims
   252                              <1> ;Else, point rsi back to that char :)
   253 000002A6 48FFCE              <1>     dec rsi
   254                              <1>     return
    13                              <2> %%_ret:
    14 000002A9 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   255                              <1> 
   256                              <1> findDelimOrCR:
   257                              <1> ;Point rsi to the first delim or cmdtail terminator
   258 000002AA AC                  <1>     lodsb
   259 000002AB 3C0D                <1>     cmp al, CR
   260 000002AD 7407                <1>     je .exit
   261 000002AF E806000000          <1>     call isALDelim
   262 000002B4 75F4                <1>     jnz findDelimOrCR
   263                              <1> .exit:
   264 000002B6 48FFCE              <1>     dec rsi
   265                              <1>     return
    13                              <2> %%_ret:
    14 000002B9 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   266                              <1> 
   267                              <1> isALDelim:
   268 000002BA 3C20                <1>     cmp al, SPC
   269                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002BC 74(B9)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   270 000002BE 3C09                <1>     cmp al, TAB
   271                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002C0 74(B9)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   272 000002C2 3C3D                <1>     cmp al, "="
   273                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002C4 74(B9)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   274 000002C6 3C2C                <1>     cmp al, ","
   275                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000002C8 74(B9)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   276 000002CA 3C3B                <1>     cmp al, ";"
   277                              <1>     return
    13                              <2> %%_ret:
    14 000002CC C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    20                                  %include "./dat/strings.asm"
     1                              <1> 
     2                              <1> ;SUBST data
     3                              <1> ;Strings
     4 000002CD 496E76616C69642044- <1> badVerStr   db "Invalid DOS Version"    ;Ends on the next line
     4 000002D6 4F532056657273696F- <1>
     4 000002DF 6E                  <1>
     5 000002E0 0A0D24              <1> crlf        db LF,CR,"$"
     6 000002E3 496E636F7272656374- <1> badParmStr  db "Incorrect number of parameters",CR,LF,"$"
     6 000002EC 206E756D626572206F- <1>
     6 000002F5 6620706172616D6574- <1>
     6 000002FE 6572730D0A24        <1>
     7 00000304 5F3A203D3E2024      <1> substStr    db "_: => $"
    21                                  ;Use a 45 QWORD stack
    22                                  Segment transient align=8 follows=.text nobits
    23                                  %include "./dat/bss.asm"
     1                              <1> ;BSS data
     2 00000000 ????????????????    <1> pSysvars    dq ?
     3 00000008 ????????????????    <1> pVar1       dq ?
     4 00000010 ????????????????    <1> pVar2       dq ?
    24 00000018 <res 168h>                  dq 45 dup (?)
    25                                  endOfAlloc:
    25          ------------------       info: assembly required 1+2+2 passes

