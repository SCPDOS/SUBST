     1                                  ; Subst!
     2                                  
     3                                  [map all ./lst/subst.map]
     4                                  [DEFAULT REL]
     5                                  
     6                                  ;
     7                                  ;Creates, deletes and displays subst drives.
     8                                  ;Order of arguments DOES NOT matter.
     9                                  ;Invoked by: 
    10                                  ; SUBST [drive 1: [drive2:]path] <- Mounts [drive2:]path on drive1:
    11                                  ; SUBST drive1: /D       <- Deletes the subst drive drive1:
    12                                  ; SUBST                  <- Displays current subst drives
    13                                  
    14                                  BITS 64
    15                                  %include "./inc/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1> %%_ret:
    14                              <1>     ret
    15                              <1> %assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro cret 1
    19                              <1> %%_base:
    20                              <1> %assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    21                              <1>     %ifdef retOff
    22                              <1>     %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <1>     %ifdef currSegVBase
    24                              <1>     j%+1 short (retOff+currSegVBase)
    25                              <1>     %else
    26                              <1>     j%+1 short retOff
    27                              <1>     %endif  ;End ifdef currSegVBase
    28                              <1>     %else 
    29                              <1>     j%-1 short %%a
    30                              <1>     return
    31                              <1> %%a:
    32                              <1>     %endif  ;End the distance measurement if
    33                              <1>     %else   
    34                              <1>     j%-1 short %%a
    35                              <1>     return
    36                              <1> %%a:
    37                              <1>     %endif  ;End ifdef retoff
    38                              <1> %endmacro
    39                              <1> 
    40                              <1> %macro retz 0
    41                              <1> cret z
    42                              <1> %endmacro
    43                              <1> 
    44                              <1> %macro retnz 0
    45                              <1> cret nz
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> %macro rete 0
    49                              <1> cret e
    50                              <1> %endmacro
    51                              <1> 
    52                              <1> %macro retne 0
    53                              <1> cret ne
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> %macro retc 0
    57                              <1> cret c
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> %macro retnc 0
    61                              <1> cret nc
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> %macro retb 0
    65                              <1> cret b
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro retnb 0
    69                              <1> cret nb
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro reta 0
    73                              <1> cret a
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro retna 0
    77                              <1> cret na
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro breakpoint 0
    81                              <1> xchg bx, bx
    82                              <1> %endmacro
    16                                  %include "./inc/dosStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous internal     ;
     4                              <1> ; SCP/DOS structures.                                   ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> ;------------------------------------------------------------------------;
     8                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
     9                              <1> ; its file system structure. This is used to locate files and structures
    10                              <1> ; on the device itself and to translate file requests to cluster chains
    11                              <1> ; to LBAs to pass to the disk driver..
    12                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    13                              <1> ; drivers Initialise routine has been called.
    14                              <1> ;------------------------------------------------------------------------;
    15                              <1> struc dpb        ;Drive Parameter Block
    16                              <1> 
    17 00000000 ??                  <1>     .bDriveNumber            db ?  ;Drive number (0=A, 1=B ...)
    18 00000001 ??                  <1>     .bUnitNumber             db ?  ;Unit number in device
    19 00000002 ????                <1>     .wBytesPerSector         dw ?  ;min 512, max 4096
    20 00000004 ??                  <1>     .bMaxSectorInCluster     db ?  ;(Maximum sector in cluster) - 1
    21 00000005 ??                  <1>     .bSectorsPerClusterShift db ?  ;Sectors per cluster exponent
    22 00000006 ????                <1>     .wFAToffset              dw ?  ;Number of reserved sectors in partition
    23 00000008 ??                  <1>     .bNumberOfFATs           db ?  ;Number of FATs
    24 00000009 ????                <1>     .wNumberRootDirEntries   dw ?  ;In 32 byte units, this is 0 for FAT32
    25 0000000B ????????            <1>     .dClusterHeapOffset      dd ?  ;Start sector of data area
    26 0000000F ????????            <1>     .dClusterCount           dd ?  ;Total number of clusters in data area
    27 00000013 ????????            <1>     .dFATlength              dd ?  ;FAT length, in sectors
    28 00000017 ????????            <1>     .dFirstUnitOfRootDir     dd ?  
    29                              <1>     ;Unit=Sector/Cluster of Root Directory (FAT12/16 = Sector, FAT32 = Cluster)
    30 0000001B ????????????????    <1>     .qDriverHeaderPtr        dq ?  ;Pointer to device driver header
    31 00000023 ??                  <1>     .bMediaDescriptor        db ?  ;Media descriptor
    32 00000024 ??                  <1>     .bAccessFlag             db ?  ;Access Flag (0 if accessed, else -1)
    33 00000025 ????????????????    <1>     .qNextDPBPtr             dq ?  ;Pointer to next DPB, -1 if at end
    34 0000002D ????????            <1>     .dFirstFreeCluster       dd ?  ;Starting cluster of free space search
    35 00000031 ????????            <1>     .dNumberOfFreeClusters   dd ?  ;Number of free clusters, -1 unknown
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> fat12MaxClustCnt    equ 4085    ;Cluster count less than this is FAT12
    40                              <1> fat16MaxClustCnt    equ 65525   ;Cluster count less than this is FAT16
    41                              <1> ;------------------------------------------------------------------------;
    42                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    43                              <1> ; All disk pathing requests go via the CDS for that drive.
    44                              <1> ; The default drive is the last accessed drive, this number is stored
    45                              <1> ; in the DOS data area.
    46                              <1> ; The CDS is stored as an array with the offset into the array being 
    47                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    48                              <1> ;
    49                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    50                              <1> ;------------------------------------------------------------------------;
    51                              <1> struc cds       ;Current Directory structure
    52 00000000 <res 43h>           <1>     .sCurrentPath        db 67 dup (?)    ;Current Directory Path String
    53 00000043 ????                <1>     .wFlags              dw ?   ;CDS Flags - 
    54 00000045 ????????????????    <1>     .qDPBPtr             dq ?   ;Ptr to the DPB of the dev using this CDS
    55 0000004D ????????            <1>     .dStartCluster       dd ?   ;Starting cluster of the directory on disk
    56 00000051 ????????????????    <1>     .qIFSPtr             dq ?   ;Reserved for IFS driver expansions
    57 00000059 ????????            <1>     .dNetStore           dd ?   ;For storing a owner dword for IFS (21h/5F03h)
    58 0000005D ????                <1>     .wBackslashOffset    dw ?   ;How many chars to skip for getting the path
    59                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    60                              <1> ; another, we save the number of chars to skip to that deep level).
    61                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    62                              <1> ; Only affects for SUBST drives, not JOIN
    63                              <1> ; Flags: Bit 15 set = Network drive
    64                              <1> ;        Bit 14 set = Physical drive
    65                              <1> ;        Bit 13 set = JOIN'ed drive
    66                              <1> ;        Bit 12 set = SUBST'ed drive
    67                              <1> ;        Bit 7  set = Redirected, not net. drive (This is how MSCDEX worked)
    68                              <1> endstruc
    69                              <1> ;CDS equates
    70                              <1> cdsRedirDrive   equ 8000h   ;All drives which use the Redirector interface
    71                              <1> cdsValidDrive   equ 4000h   ;CDS valid
    72                              <1> cdsJoinDrive    equ 2000h   ;CDS for joined drives
    73                              <1> cdsSubstDrive   equ 1000h   ;Drives formed by Subst
    74                              <1> cdsRdirLocDrive equ 0080h   ;Redirector but Local
    75                              <1> ;------------------------------------------------------------------------;
    76                              <1> ; The SFT is a way to allow applications to open file handles to files 
    77                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    78                              <1> ; under the first header, and then a second header will be linked to the 
    79                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    80                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    81                              <1> ; using the FCBS= command. Default FCBS=5.
    82                              <1> ;
    83                              <1> ; A file handle describes the file, and the location within the file that
    84                              <1> ; we are reading. The file handle can be manipulated without the file
    85                              <1> ; being in memory, thus allowing the user to access data without needing 
    86                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    87                              <1> ; accessing devices, by treating them as files with their drivers 
    88                              <1> ; responding and translating the manipulations of the file handle itself.
    89                              <1> ; Neither the driver nor the application should see or use the SFT for
    90                              <1> ; the handle, as it is subject to change (and will change when file 
    91                              <1> ; sharing provisions are included). The DOS will make requests to the 
    92                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    93                              <1> ; track of the information in the SFT entry for that handle. 
    94                              <1> ;
    95                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    96                              <1> ; can point to the same file. It all depends on what the applications 
    97                              <1> ; want to do with the File.
    98                              <1> ;
    99                              <1> ; !!!!IMPORTANT!!!!
   100                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   101                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   102                              <1> ;
   103                              <1> ;Each SFT may look like this:
   104                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   105                              <1> ;            |                |
   106                              <1> ;       wNumFiles*sft    wNumFiles*sft
   107                              <1> ;
   108                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   109                              <1> ; System FCBs.
   110                              <1> ;
   111                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   112                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   113                              <1> ;
   114                              <1> ; DEFAULT FILES=8, MINIMUM FILES=5
   115                              <1> ; DEFAULT FCBS=5,  MINIMUM FCBS=5
   116                              <1> ;------------------------------------------------------------------------;
   117                              <1> struc sfth   ;System file table header
   118                              <1> ; This is the SFT header.
   119                              <1> ; This structure comes before the start of the first file in the array/table.
   120 00000000 ????????????????    <1>     .qNextSFTPtr dq ?    ;Pointer to the next SFT
   121 00000008 ????                <1>     .wNumFiles   dw ?    ;Number of files in this table
   122                              <1> endstruc
   123                              <1> 
   124                              <1> struc sft
   125                              <1> ;This is the file struc itself
   126 00000000 ????                <1>     .wNumHandles dw ?    ;Number of handles pointing to this file
   127 00000002 ????                <1>     .wOpenMode   dw ?    ;File access permissions and behvaiours
   128 00000004 ??                  <1>     .bFileAttrib db ?    ;Regular File Attributes
   129 00000005 ????                <1>     .wDeviceInfo dw ?    ;Includes unit number if a block device
   130 00000007 ????????????????    <1>     .qPtr        dq ?    ;IF char, ptr to device driver header, ELSE DPBptr
   131 0000000F ????????            <1>     .dStartClust dd ?    ;Start cluster of file pointed to by SFT entry
   132 00000013 ????                <1>     .wTime       dw ?    ;File Time, updated on open and writes
   133 00000015 ????                <1>     .wDate       dw ?    ;File Date, updated on open and writes
   134 00000017 ????????            <1>     .dFileSize   dd ?    ;File Size, in bytes
   135 0000001B ????????            <1>     .dCurntOff   dd ?    ;Current Offset pointed to by SFT entry, in bytes
   136 0000001F ????????            <1>     .dRelClust   dd ?    ;Rel cluster pointed to by SFT entry
   137 00000023 ????????            <1>     .dAbsClusr   dd ?    ;Absolute cluster pointed to by SFT entry
   138 00000027 ????????????????    <1>     .qDirSect    dq ?    ;Abs number of sector containing directory entry 
   139 0000002F ??                  <1>     .bNumDirEnt  db ?    ;Directory entry within dir sector (byte offset/32)
   140 00000030 <res Bh>            <1>     .sFileName   db 11 dup (?)   ;8.3 Filename
   141 0000003B ????????????????    <1>     .qSharePtr   dq ?    ;SHARE pointer to previous SFT sharing same file
   142 00000043 ????                <1>     .wMachNum    dw ?    ;SHARE number of network machine opening file
   143 00000045 ????????????????    <1>     .qPSPOwner   dq ?    ;Addr of PSP of program which first opened this file
   144 0000004D ????                <1>     .wShareRec   dw ?    ;offset within SHARE code segment of sharing record
   145                              <1> ;                           0 means no record
   146                              <1> endstruc
   147                              <1> ;Open Mode equates
   148                              <1> ;Access modes   Bits[2:0]
   149                              <1> ReadAccess      equ 0h
   150                              <1> WriteAccess     equ 1h
   151                              <1> RWAccess        equ 2h
   152                              <1> ;Bit 3 reserved 0
   153                              <1> ;Sharing modes  Bits[6:4]
   154                              <1> CompatShare     equ 0h
   155                              <1> denyRWShare     equ 10h
   156                              <1> denyWriteShare  equ 20h
   157                              <1> denyReadShare   equ 30h
   158                              <1> denyNoneShare   equ 40h
   159                              <1> ;NetFCB is for files open by a local server, handling IO from a remote
   160                              <1> ; client by proxy opened by an FCB! Sets the Net bit to indicate this. 
   161                              <1> ;Thus, this is a handle with no JFT entry! Server handles its own JFT!
   162                              <1> netFCBShare     equ 70h     
   163                              <1> noInherit       equ 80h
   164                              <1> ;Bits 8-12 reserved 0
   165                              <1> ;Fancy open mode bits
   166                              <1> diskFullFail    equ 2000h   ;Reserved: If set, trigger Int 24h on disk full.
   167                              <1> noBufferWrites  equ 4000h   ;Reserved: If set, flush after each buffer write.
   168                              <1> ;Once share is loaded, if a local FCB open occurs, mark the sft as so.
   169                              <1> FCBopenedFile   equ 8000h   ;If set, file is opened by FCB, else handle based.
   170                              <1> 
   171                              <1> ;Attribute Byte
   172                              <1> readOnlyFile    equ 1h
   173                              <1> hiddenFile      equ 2h
   174                              <1> systemFile      equ 4h
   175                              <1> volLabelFile    equ 8h
   176                              <1> directoryFile   equ 10h ;Directory entry
   177                              <1> archiveFile     equ 20h
   178                              <1> charFile        equ 40h ;Reserved, never found in dir
   179                              <1> ;Device Info equates
   180                              <1> ;For a block device, bits [5:0] contain the drive number
   181                              <1> charDevConIn    equ 1h  ;If set, device is CON input
   182                              <1> charDevConOut   equ 2h  ;If set, device is CON output
   183                              <1> charDevNulDev   equ 4h  ;If set, device is NULL device
   184                              <1> charDevClockDev equ 8h  ;If set, device is CLOCK device
   185                              <1> charDevFastOut  equ 10h ;If set, device supports INT 29h
   186                              <1> charDevBinary   equ 20h ;If set, r/w char device in Binary mode!!!
   187                              <1> charDevNoEOF    equ 40h ;If set, no EOF when reading from device!!
   188                              <1> blokFileNoFlush equ 40h ;Set if file is synchronised with hard store!
   189                              <1> devCharDev      equ 80h ;If set, it is a char device!
   190                              <1> charDevNetSpool equ 800h    ;If set, device is a network spooler
   191                              <1> devNoInherit    equ 1000h   ;If set, handle not inherited by child processes
   192                              <1> charDevNamePipe equ 2000h   ;If set, device is a named pipe
   193                              <1> blokNoDTonClose equ 4000h   ;If set, dont update date and time when closing
   194                              <1> devRedirDev     equ 8000h   ;If set, dev/file is redirected!
   195                              <1>  
   196                              <1> ;------------------------------------------------------------------------;
   197                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   198                              <1> ; to an internal buffer, and then copying it to the specified location
   199                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   200                              <1> ; another request for the same sector from the same device is made, so 
   201                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   202                              <1> ; size, selected according to the largest detected sector size during 
   203                              <1> ; the initial loadup.
   204                              <1> ;
   205                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   206                              <1> ;
   207                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   208                              <1> ;------------------------------------------------------------------------;
   209                              <1> 
   210                              <1> struc bufferHdr
   211 00000000 ????????????????    <1>     .nextBufPtr  dq  ?   ;Pointer to the next buffer in the chain or -1 at end
   212                              <1>     .wDrvNumFlg:         ;Read as a word to get the following two bytes!
   213 00000008 ??                  <1>     .driveNumber db  ?   ;Drive number the buffer is used for (or -1 for free)
   214 00000009 ??                  <1>     .bufferFlags db  ?   ;Standard Flags
   215 0000000A ????????????????    <1>     .bufferLBA   dq  ?   ;LBA the buffer contains
   216 00000012 ??                  <1>     .bufFATcopy  db  ?   ;Number of copies of the FAT to write (1 if non-FAT)
   217 00000013 ????????            <1>     .bufFATsize  dd  ?   ;Number of sectors per FAT (or 0 if non-FAT)
   218 00000017 ????????????????    <1>     .driveDPBPtr dq  ?   ;Pointer to the device DPB block
   219 0000001F ??                  <1>     .reserved    db  ?   ;Alignment byte
   220                              <1>     .dataarea:             ;Points to the start of the data area
   221                              <1> endstruc
   222                              <1> ;Buffer Flag equates
   223                              <1> dosBuffer   equ 1h  ;Sector 0 (BPB/VPB) in buffer
   224                              <1> fatBuffer   equ 2h  ;FAT sector in buffer
   225                              <1> dirBuffer   equ 4h  ;Directory sector in buffer
   226                              <1> dataBuffer  equ 8h  ;File Data sector in buffer
   227                              <1> refBuffer   equ 20h ;Data in buffer has been referenced by an application
   228                              <1> dirtyBuffer equ 40h ;Data in buffer modified by an application
   229                              <1> freeBuffer  equ 00FFh   ;A word which goes into the drive number to clear both fields
   230                              <1> ;Note! A buffer is marked as referenced when the buffer is "obtained" by a syscall
   231                              <1> ;------------------------------------------------------------------------;
   232                              <1> ; Memory control block for each memory arena
   233                              <1> ;------------------------------------------------------------------------;
   234                              <1> struc mcb
   235 00000000 ??                  <1>     .marker     db ?  ;M = Member of the MCB chain. Z = Last member
   236 00000001 ????????????????    <1>     .owner      dq ?  ;Owning application PSP (para aligned) or 0 for free
   237 00000009 ????????            <1>     .blockSize  dd ?  ;Number of contiguous paragraphs owned by this block
   238                              <1>     ;The following byte is reserved outside of sysinit
   239 0000000D ??                  <1>     .subSysMark db ?  ;Marks the optional DOS subsystem of the MCB
   240 0000000E ????                <1>     .reserved   db 2 dup (?) 
   241                              <1>     .program:
   242                              <1> endstruc
   243                              <1> ;MCB equates
   244                              <1> mcbOwnerHole    equ 7   ;Owner = 7 => Memory hole, always fail free/realloc
   245                              <1> mcbOwnerFree    equ 0   ;Owner = 0 => Free and available space
   246                              <1> mcbOwnerDOS     equ 8   ;Owner = 8 => Owned by DOS
   247                              <1> mcbOwnerNewDOS  equ 9   ;Owner = 9 => New Kernel driver alloc. Needs setting to 8.
   248                              <1> mcbMarkCtn      equ "M"
   249                              <1> mcbMarkEnd      equ "Z"
   250                              <1> ;The following are used on MCB's that belong to DOS, that are not part of the
   251                              <1> ; main kernel (i.e. the CONFIG.SYS optional parts).
   252                              <1> mcbSubDriver    equ "D" ;Any memory allocated for a device driver's code.
   253                              <1> mcbSubDrvExtra  equ "L" ;Any memory allocated by a device driver.
   254                              <1> mcbSubDrvDPB    equ "P" ;Blocks used for DPB's are marked so.
   255                              <1> mcbSubIFS       equ "I" ;Unused for now
   256                              <1> mcbSubFiles     equ "F" ;Any memory allocated for Files.
   257                              <1> mcbSubFCBS      equ "X" ;Unused for now
   258                              <1> mcbSubBuffers   equ "B" ;Any memory allocated for Buffers.
   259                              <1> mcbSubCDS       equ "L" ;Any memory allocated to store a CDS.
   260                              <1> mcbSubStacks    equ "S" ;Unused for now
   261                              <1> 
   262                              <1> 
   263                              <1> memFirstFit     equ 0   ;First free block goes to application
   264                              <1> memBestFit      equ 1   ;Block whos size closest matches requirement
   265                              <1> memLastFit      equ 2   ;Last free block goes to application
   266                              <1> 
   267                              <1> ;Owner = Para aligned address => Owning application PSP
   268                              <1> ;...To consider...
   269                              <1> ;Owner = Non-para aligned address => Error? Should maybe lock up system?
   270                              <1> ;blockSize counts the number of paragraphs FROM .program TO THE NEXT MCB!
   271                              <1> ;------------------------------------------------------------------------;
   272                              <1> ; For Int 21h, the callers registers are saved on their stack in the 
   273                              <1> ; following order, thus allowing for return values to be placed in the 
   274                              <1> ; registers by accessing the caller register stack frame.
   275                              <1> ;------------------------------------------------------------------------;
   276                              <1> struc callerFrame
   277 00000000 ????????????????    <1>     .rax    dq ?  ;Bottom of frame, pointer to rax saved in oldRSP
   278 00000008 ????????????????    <1>     .rbx    dq ?    
   279 00000010 ????????????????    <1>     .rcx    dq ?
   280 00000018 ????????????????    <1>     .rdx    dq ?
   281 00000020 ????????????????    <1>     .rsi    dq ?
   282 00000028 ????????????????    <1>     .rdi    dq ?
   283 00000030 ????????????????    <1>     .rbp    dq ?
   284 00000038 ????????????????    <1>     .r8     dq ?  ;To be removed if truly not needed
   285 00000040 ????????????????    <1>     .r9     dq ?
   286                              <1> ;Pushed by Processor when invoked via Interrupt
   287 00000048 ????????????????    <1>     .rip    dq ?
   288 00000050 ????????????????    <1>     .cs     dq ?
   289 00000058 ????????????????    <1>     .flags  dq ?
   290                              <1> endstruc
   291                              <1> 
   292                              <1> struc dpl
   293                              <1> ;DOS parameter list, pointer to this stack is passed to DOS in rdx on
   294                              <1> ; server calls
   295 00000000 ????????????????    <1>     .rax    dq ?
   296 00000008 ????????????????    <1>     .rbx    dq ?
   297 00000010 ????????????????    <1>     .rcx    dq ?
   298 00000018 ????????????????    <1>     .rdx    dq ?
   299 00000020 ????????????????    <1>     .rsi    dq ?
   300 00000028 ????????????????    <1>     .rdi    dq ?
   301 00000030 ????????????????    <1>     .r8     dq ?
   302 00000038 ????????????????    <1>     .r9     dq ?
   303 00000040 ????????????????    <1>     .align  dq ?
   304 00000048 ????????????????    <1>     .compID dq ?  ;Computer id, low word used only
   305 00000050 ????????????????    <1>     .procID dq ?  ;Process ID
   306                              <1> endstruc
   307                              <1> 
   308                              <1> struc cfgFrame  ;Frame used for config.sys parsing
   309 00000000 ????????????????    <1>     .oldRBP         dq ?  ;Ptr to DOSSEG
   310 00000008 ????????????????    <1>     .newBuffers     dq ?  ;New buffers value
   311 00000010 ????????????????    <1>     .newSFTVal      dq ?
   312 00000018 ????????????????    <1>     .newFCBSVal     dq ?
   313 00000020 ????????????????    <1>     .newProtFCBSVal dq ?  ;Number of protected FCBS
   314 00000028 ????????????????    <1>     .newLastdrive   dq ?
   315 00000030 ????????????????    <1>     .newStacks      dq ?  ;Ignored for now
   316 00000038 ????????????????    <1>     .newStackSize   dq ?  ;Ignored for now
   317 00000040 ????????????????    <1>     .cfgHandle      dq ?  ;CONFIG.SYS handle
   318 00000048 ????????????????    <1>     .lastLine       dq ?  ;Set if the last line is current
   319 00000050 ????????????????    <1>     .linePtr        dq ?  ;Ptr to line buffer of line being processed
   320 00000058 ????????????????    <1>     .driverBreak    dq ?  ;Ptr to the pathname terminator 
   321 00000060 ????????????????    <1>     .breakChar      dq ?  ;Char that was replaced by null for terminator
   322                              <1> endstruc
   323                              <1> 
   324                              <1> struc filename
   325                              <1> ;8.3 File name struct
   326 00000000 ????????????????    <1>     .fName  db 8 dup (?)
   327 00000008 ??????              <1>     .fExt   db 3 dup (?)
   328                              <1> endstruc
   329                              <1> 
   330                              <1> struc ffBlock   ;The structure of the Find First structure at the DTA
   331 00000000 ??                  <1>     .driveNum   db ?  ;Drive we are searching on, 1 based number
   332 00000001 <res Bh>            <1>     .template   db 11 dup (?) ;Search template (? meaning anything)
   333 0000000C ??                  <1>     .attrib     db ?  ;Search attribute
   334 0000000D ????????            <1>     .dirOffset  dd ?  ;32 byte entry within dir cluster
   335 00000011 ????????            <1>     .parDirClus dd ?  ;Parent Directory Cluster number
   336 00000015 ??                  <1>     .attribFnd  db ?  ;Attrib of file found
   337 00000016 ????                <1>     .fileTime   dw ?  ;File time
   338 00000018 ????                <1>     .fileDate   dw ?  ;File date
   339 0000001A ????????            <1>     .fileSize   dd ?  ;Number of bytes
   340 0000001E <res Dh>            <1>     .asciizName db 13 dup (?) ;ASCIIZ name with dot and terminating nul
   341                              <1> endstruc
   342                              <1> 
   343                              <1> 
   344                              <1> dfltJFTsize equ 20  ;Default size of PSP JFT
   345                              <1> struc psp
   346 00000000 ????                <1>     .return     db 2 dup (?)  ;Should always be CDh 20h, same place as DOS
   347 00000002 ????????            <1>     .allocSize  dd ?  ;Number of paras in init alloc or when exiting as TSR.
   348 00000006 ????????            <1>                 dd ?  ;Reserved 4 bytes
   349 0000000A ????????????????    <1>     .oldInt22h  dq ?  ;Int 22h pointer on overlay load
   350 00000012 ????????????????    <1>     .oldInt23h  dq ?  ;Int 23h pointer on overlay load
   351 0000001A ????????????????    <1>     .oldInt24h  dq ?  ;Int 24h pointer on overlay load
   352 00000022 ????????????????    <1>     .parentPtr  dq ?  ;Pointer to parent process PSP
   353                              <1> ;If jftSize > 20, then the QWORD at .jobFileTbl becomes a pointer
   354                              <1> ; to the actual in use JFT and the other 12 bytes are left undefined.
   355                              <1> ;If jftSize < 20 (DOS will never set it so), then it is considered as 20
   356                              <1> ;If the user tries to reduce handle count to 20 or less, then the PSP JFT is 
   357                              <1> ; always used and jftSize.
   358                              <1>     .externalJFTPtr:    ;Ptr to external JFT array (first byte AFTER MCB)
   359 0000002A <res 14h>           <1>     .jobFileTbl db dfltJFTsize dup (?) ;Main File handle array, JFT
   360 0000003E ????????????????    <1>     .envPtr     dq ?  ;Pointer to the environment
   361 00000046 ????????????????    <1>     .rspPtr     dq ?  ;Pointer to rsp on entry to Int 21h
   362 0000004E ????                <1>     .jftSize    dw ?  ;JFT array size, 20 => PSP JFT in use
   363 00000050 ??????              <1>     .unixEntry  db 3 dup (?)  ;Must always be CDh 21h CBh, same place as DOS
   364 00000053 ????????????????    <1>     .prevPSP    dq ?  ;Pointer to the previous PSP in chain (used by SHARE)
   365 0000005B ??                  <1>                 db ?  ;Reserved byte
   366                              <1> ;The below are in the same place as in DOS.
   367                              <1>     .cmdLineArgPtr: ;Symbol for future use
   368 0000005C <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1 
   369 0000006C <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
   370                              <1>     .dta:   ;Pointer to the default DTA in the PSP
   371 00000080 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
   372 00000081 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
   373                              <1> endstruc
   374                              <1> 
   375                              <1> struc clkStruc
   376 00000000 ????                <1>     .dateWord   dw ?
   377 00000002 ??                  <1>     .minutes    db ?
   378 00000003 ??                  <1>     .hours      db ?
   379 00000004 ??                  <1>     .hseconds   db ?  ;Hundreths of seconds
   380 00000005 ??                  <1>     .seconds    db ?
   381                              <1> endstruc
   382                              <1> 
   383                              <1> 
   384                              <1> struc extCtryStruc
   385 00000000 ??                  <1>     .infoIDCode db ?    ;Information ID code (01h)
   386 00000001 ????                <1>     .strucSize  dw ?    ;Length of the structure  (42 or less)
   387 00000003 ????                <1>     .ctryID     dw ?    ;Country ID number
   388 00000005 ????                <1>     .cpNumber   dw ?    ;Code page number
   389 00000007 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   390                              <1>                         ;0 = month day year hh:mm:ss
   391                              <1>                         ;1 = day month year hh:mm:ss
   392                              <1>                         ;2 = year month day hh:mm:ss
   393 00000009 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   394 0000000E ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   395 00000010 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   396 00000012 ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   397 00000014 ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   398 00000016 ??                  <1>     .currFmt    db ?    ;Currency Format
   399                              <1>                         ;0 = Symbol leads, without space
   400                              <1>                         ;1 = Symbol follows, without space
   401                              <1>                         ;2 = Symbol leads, one space
   402                              <1>                         ;3 = Symbol follows, one space
   403                              <1>                         ;4 = Symbol replace decimal separator
   404 00000017 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   405 00000018 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   406 00000019 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   407 00000021 ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   408 00000023 <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   409                              <1> endstruc
   410                              <1> 
   411                              <1> struc countryStruc
   412 00000000 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   413                              <1>                         ;0 = month day year hh:mm:ss
   414                              <1>                         ;1 = day month year hh:mm:ss
   415                              <1>                         ;2 = year month day hh:mm:ss
   416 00000002 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   417 00000007 ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   418 00000009 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   419 0000000B ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   420 0000000D ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   421 0000000F ??                  <1>     .currFmt    db ?    ;Currency Format
   422                              <1>                         ;0 = Symbol leads, without space
   423                              <1>                         ;1 = Symbol follows, without space
   424                              <1>                         ;2 = Symbol leads, one space
   425                              <1>                         ;3 = Symbol follows, one space
   426                              <1>                         ;4 = Symbol replace decimal separator
   427 00000010 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   428 00000011 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   429 00000012 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   430 0000001A ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   431 0000001C <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   432                              <1> endstruc
   433                              <1> 
   434                              <1> ;Critical Error AH bitfield equates
   435                              <1> critRead    equ 0h
   436                              <1> critWrite   equ 1h
   437                              <1> critDOS     equ 0h
   438                              <1> critFAT     equ 2h
   439                              <1> critDir     equ 4h
   440                              <1> critData    equ 6h
   441                              <1> critFailOK  equ 8h
   442                              <1> critRetryOK equ 10h
   443                              <1> critIgnorOK equ 20h
   444                              <1> critCharDev equ 80h
   445                              <1> 
   446                              <1> critIgnore  equ 0
   447                              <1> critRetry   equ 1
   448                              <1> critAbort   equ 2
   449                              <1> critFail    equ 3
   450                              <1> 
   451                              <1> ;MISC ASCII control chars
   452                              <1> NUL equ 00h ;^@         | ASCII Null
   453                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text) 
   454                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
   455                              <1> BEL equ 07h ;^G         | ASCII Bell
   456                              <1> BSP equ 08h ;^H         | ASCII Backspace
   457                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
   458                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
   459                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
   460                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
   461                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
   462                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
   463                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
   464                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
   465                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
   466                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
   467                              <1> SPC equ 20h ;Printable  | ASCII Space
   468                              <1> ;This last one is NEVER printed with a caret as it is a console control char
   469                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
   470                              <1> 
   471                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
   472                              <1> ;Extended Ascii Codes
   473                              <1> eF1     equ 3Bh ;F1 second byte
   474                              <1> eF2     equ 3Ch ;F2 second byte
   475                              <1> eF3     equ 3Dh ;F3 second byte
   476                              <1> eF4     equ 3Eh ;F4 second byte
   477                              <1> eF5     equ 3Fh ;F5 second byte
   478                              <1> eF6     equ 40h ;F6 second byte
   479                              <1> eF7     equ 41h ;F7 second byte
   480                              <1> eCursL  equ 4Bh ;Cursor Left second byte
   481                              <1> eCursR  equ 4Dh ;Cursor Right second byte
   482                              <1> eIns    equ 52h ;Insert second byte
   483                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
   484                              <1> 
   485                              <1> ;Default Configuration for the system
   486                              <1> 
   487                              <1> buffersDefault  equ 30
   488                              <1> filesDefault    equ 20
   489                              <1> fcbsDefault     equ 4
   490                              <1> safeFcbsDeflt   equ 0
   491                              <1> lastDriveDeflt  equ 5   
   492                              <1> 
   493                              <1> ;ASCII char property table equates. If such a bit is clear in signature in table
   494                              <1> ; then the char has this property.
   495                              <1> badChar     equ 1   ;Bad ASCIIZ filename char
   496                              <1> termChar    equ 2   ;Terminator char type
   497                              <1> sepChar     equ 4   ;Separator char type
   498                              <1> badFCBChar  equ 8   ;FCB filename char
   499                              <1> 
   500                              <1> struc fatDirEntry
   501                              <1> 
   502 00000000 <res Bh>            <1>     .name       db 11 dup (?) ;8.3 File Name w/o fullstop
   503 0000000B ??                  <1>     .attribute  db ?  ;Usual attributes
   504 0000000C ??                  <1>     .ntRes      db ?  ;Reserved 0
   505 0000000D ??                  <1>     .crtTimeT   db ?  ;Count of tenths of a second of file creation time <=199
   506 0000000E ????                <1>     .crtTime    dw ?  ;Creation time, granularity of 2 seconds
   507 00000010 ????                <1>     .crtDate    dw ?  ;Creation date
   508 00000012 ????                <1>     .lastAccDat dw ?  ;Last Read/Write date, not 100% supported (consider later)
   509 00000014 ????                <1>     .fstClusHi  dw ?  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
   510 00000016 ????                <1>     .wrtTime    dw ?  ;Last modification (write) time
   511 00000018 ????                <1>     .wrtDate    dw ?  ;Last modification (write) date
   512 0000001A ????                <1>     .fstClusLo  dw ?  ;Lo word of 1st data cluster for file/dir
   513 0000001C ????????            <1>     .fileSize   dd ?  ;32-bit quantity with size of file described by entry
   514                              <1> 
   515                              <1> endstruc
    17                                  %include "./inc/dosError.inc"
     1                              <1> ;DOS Error codes
     2                              <1> 
     3                              <1> ;Extended Error Codes
     4                              <1> errInvFnc   equ 1   ;Invalid function number
     5                              <1> errFnf      equ 2   ;File not found
     6                              <1> errPnf      equ 3   ;Path not found
     7                              <1> errNhl      equ 4   ;Too many open handles, no handles left
     8                              <1> errAccDen   equ 5   ;Access denied (to resource)
     9                              <1> errBadHdl   equ 6   ;Invalid handle
    10                              <1> errMCBbad   equ 7   ;MCB's destroyed
    11                              <1> errNoMem    equ 8   ;Insufficient memory
    12                              <1> errMemAddr  equ 9   ;Invalid Memory Block Address
    13                              <1> errBadEnv   equ 10  ;Invalid environment
    14                              <1> errBadFmt   equ 11  ;Invalid format (path etc)
    15                              <1> errAccCde   equ 12  ;Invalid Access Code    ?
    16                              <1> errInvDat   equ 13  ;Invalid data
    17                              <1> ;           equ 14  ;Reserved
    18                              <1> errBadDrv   equ 15  ;Invalid drive specified
    19                              <1> errDelCD    equ 16  ;Attempt to delete the current directory
    20                              <1> errDevUnk   equ 17  ;Not the same device (Device Unknown)
    21                              <1> errNoFil    equ 18  ;No more files, no match found
    22                              <1> ;The following are Driver error codes + 19
    23                              <1> drvErrShft  equ 19  ;Used to shift Driver error codes to extended error codes
    24                              <1> errWpd      equ 19  ;Attempt to write on write protected disk
    25                              <1> errUnkUnt   equ 20  ;Unknown Unit
    26                              <1> errDrvNR    equ 21  ;Drive not ready
    27                              <1> errUnkCmd   equ 22  ;Unknown Command
    28                              <1> errCRCerr   equ 23  ;Data (CRC) error
    29                              <1> errBadRLn   equ 24  ;Bad request structure length
    30                              <1> errSekErr   equ 25  ;Seek error
    31                              <1> errUnkMed   equ 26  ;Unknown media type
    32                              <1> errSecNF    equ 27  ;Sector not Found
    33                              <1> errNoPap    equ 28  ;Printer out of paper
    34                              <1> errWF       equ 29  ;Write fault
    35                              <1> errRF       equ 30  ;Read fault
    36                              <1> errGF       equ 31  ;General fault
    37                              <1> ;----------------------------------------------
    38                              <1> ;The following two go inbetween the Disk errors
    39                              <1> errShrVio   equ 32  ;Sharing violations
    40                              <1> errLokVio   equ 33  ;File Lock violation
    41                              <1> ;----------------------------------------------
    42                              <1> errIDC      equ 34  ;Driver code, Invalid Disk Change
    43                              <1> errNoFCB    equ 35  ;FCB unavailable
    44                              <1> errShrFul   equ 36  ;Sharing buffer full
    45                              <1> 
    46                              <1> errNoNet    equ 50  ;Network request not supported, generic net fail
    47                              <1> 
    48                              <1> errFilExist equ 80  ;File already exists
    49                              <1> errDirExist equ 82  ;Directory already exists
    50                              <1> errFI44     equ 83  ;Fail on Int 24h
    51                              <1> errRedir    equ 84  ;Too many levels of redirection
    52                              <1> errDupRedir equ 85  ;Trying to redirect a redirection
    53                              <1> errBadPass  equ 86  ;Bad password
    54                              <1> errBadParam equ 87  ;Bad parameter passed to request
    55                              <1> errNetWrite equ 88  ;Network Write Fault
    56                              <1> ;-----------------------------------------------------------------------------
    57                              <1> ;Error Loci
    58                              <1> eLocUnk     equ 1   ;Unknown locus, nonspecific or not appropriate
    59                              <1> eLocDsk     equ 2   ;Disk, related to Random Access to a disk or block device
    60                              <1> eLocNet     equ 3   ;Network related issues, shouldnt affect us (yet!)
    61                              <1> eLocChr     equ 4   ;Serial/Character Device error
    62                              <1> eLocMem     equ 5   ;Related to RAM
    63                              <1> ;-----------------------------------------------------------------------------
    64                              <1> ;Error Actions
    65                              <1> eActRet     equ 1   ;Retry
    66                              <1> eActDRet    equ 2   ;Delay then retry (Try again later)
    67                              <1> eActUsr     equ 3   ;Ask user to re-input data, i.e. bad filename or something
    68                              <1> eActAbt     equ 4   ;Abort with cleanup
    69                              <1> eActKil     equ 5   ;Abort without cleanup
    70                              <1> eActIgn     equ 6   ;Ignore error
    71                              <1> eActRetUsr  equ 7   ;Retry after user intervention (i.e swap remdev)
    72                              <1> ;-----------------------------------------------------------------------------
    73                              <1> ;Error classes
    74                              <1> eClsOoR     equ 1   ;Out of resources, no mem or handles
    75                              <1> eClsTS      equ 2   ;Temp sitch, should go away
    76                              <1> eClsAuth    equ 3   ;Authorisation, e.g. file permission error 
    77                              <1> eClsInt     equ 4   ;Internal DOS error or bug
    78                              <1> eClsHrdFlt  equ 5   ;Hardware Failure
    79                              <1> eClsSysFlt  equ 6   ;System Failure, i.e. missing or bad cfg files
    80                              <1> eClsAppFlt  equ 7   ;Application Program error, inconsistent requests etc...
    81                              <1> eClsNotFnd  equ 8   ;Resource not found (such as free SFT entry etc...)
    82                              <1> eClsBadFmt  equ 9   ;Bad format for resource
    83                              <1> eClsLocked  equ 10  ;Resource Locked
    84                              <1> eClsMedia   equ 11  ;Error is on medium, i.e. wrong or damaged remdev
    85                              <1> eClsClash   equ 12  ;Resource already exists!
    86                              <1> eClsUnk     equ 13  ;Unknown class
    18                                  %include "./inc/dosVars.inc"
     1                              <1> struc sysVars
     2 00000000 ????????????????    <1>     .dpbHeadPtr  dq ?    ;Pointer to the first DPB in the DPB chain x
     3 00000008 ????????????????    <1>     .sftHeadPtr  dq ?    ;Pointer to the first SFT header in SFT chain
     4 00000010 ????????????????    <1>     .clockPtr    dq ?    ;Pointer to the current active CLOCK$ device header x
     5                              <1>     ;                    The last driver loaded with the CLOCK$ bit[3] set 
     6 00000018 ????????????????    <1>     .vConPtr     dq ?    ;Ptr to the devdrv of the char dev controlling vCon x
     7                              <1>     ;                    The last driver loaded with the STDIN bit[0] set
     8 00000020 ????                <1>     .maxBytesSec dw ?    ;Maximum number of bytes per sector (size of buffers)x
     9 00000022 ????????????????    <1>     .bufHeadPtr  dq ?    ;Pointer to the head of the disk buffer chain x
    10 0000002A ????????????????    <1>     .cdsHeadPtr  dq ?    ;Pointer to the head of the CDS array x
    11 00000032 ????????????????    <1>     .fcbsHeadPtr dq ?    ;Pointer to the head of the System FCB chain
    12 0000003A ????                <1>     .numSafeSFCB dw ?    ;Number of protected FCBs (y in FCBS=x,y)
    13 0000003C ??                  <1>     .numPhysVol  db ?    ;Number of physical volumes in the system x
    14 0000003D ??                  <1>     .lastdrvNum  db ?    ;Value of LASTDRIVE (default = 5) [Size of CDS array]x
    15 0000003E ??                  <1>     .numBuffers  db ?    ;Buffers=30 default
    16 0000003F <res 22h>           <1>     .nulDevHdr   db 22h dup (?)
    17 00000061 ??                  <1>     .numJoinDrv  db ?    ;Number of Joined Drives
    18                              <1> endstruc
    19                              <1> 
    20                              <1> ioReqPkt_size equ 2Ah
    21                              <1> 
    22                              <1> struc sda
    23 00000000 ??                  <1>     .critErrFlag db ?  ;Critical error flag, set on entry to Int 24h x
    24 00000001 ??                  <1>     .inDOS       db ?  ;Inc on each DOS call, dec when leaving x
    25 00000002 ??                  <1>     .errorDrv    db ?  ;Drive on which error occured or FFh x
    26 00000003 ??                  <1>     .errorLocus  db ?  ;Where the error took place  
    27 00000004 ????                <1>     .errorExCde  dw ?  ;Extended Error Code
    28 00000006 ??                  <1>     .errorAction db ?  ;Suggested action for error  
    29 00000007 ??                  <1>     .errorClass  db ?  ;Error Class
    30 00000008 ????????????????    <1>     .errorVolLbl dq ?    ;Sets a ptr to the volume label of the error disk
    31 00000010 ????????????????    <1>     .currentDTA  dq ?  ;Address of the current DTA x
    32 00000018 ????????????????    <1>     .currentPSP  dq ?  ;Address of current PSP x
    33 00000020 ????????????????    <1>     .xInt23hRSP  dq ?  ;Saves RSP across an Int 23h call
    34 00000028 ????                <1>     .errorLevel  dw ?  ;Last return code returned by Int 21h/4Ch x
    35 0000002A ??                  <1>     .currentDrv  db ?  ;Default drive x
    36 0000002B ??                  <1>     .breakFlag   db ?  ;If set, check for CTRL+C on all DOS calls x
    37 0000002C ????????????????    <1>     .oldRAX      dq ?  ;Store rax on entering Int21h or returning Int 23h
    38 00000034 ????????????????    <1>     .serverPSP   dq ?  ;PSP of prog making server request, used by net & share
    39 0000003C ????                <1>     .machineNum  dw ?  ;for sharing/networking 00h = default number (us)
    40 0000003E ????????????????    <1>     .firstMCB    dq ?  ;First fit MCB for request
    41 00000046 ????????????????    <1>     .bestMCB     dq ?  ;Best fit MCB for request
    42 0000004E ????????????????    <1>     .lastMCB     dq ?  ;Last fit MCB for request
    43 00000056 ????                <1>     .dirEntryNum dw ?  ;Offset into directory of entry we are looking for
    44 00000058 ??                  <1>     .volIdFlag   db ?    ;If set, we are searching for a volume ID
    45 00000059 ????????????????    <1>     .xInt24hRSP  dq ?  ;RSP across an Int 24h call
    46 00000061 ??                  <1>     .Int24bitfld db ?  ;Copies the bit field given to the Int 24h handler
    47 00000062 ??                  <1>     .fileDirFlag db ?  ;File/Directory flag. 0 = Dir, 0 = File
    48 00000063 ??                  <1>     .Int24Fail   db ?  ;Set if Int 24h returned fail
    49 00000064 ????????????????    <1>     .oldoldRSP   dq ?  ;RSP at prev Int 21h entry if called from within Int 21h
    50 0000006C ????????????????    <1>     .dosReturn   dq ?  ;Used as a var to return when juggling stack
    51 00000074 ????????????????    <1>     .oldRSP      dq ?  ;RSP when entering Int 21h
    52 0000007C ????????????????    <1>     .oldRBX      dq ?  ;Temp var to save value of rbx during an Int 21 call
    53 00000084 ??                  <1>     .dirFlag     db ?  ;Directory Flag. 0 => Search for Dir, 1 => for File
    54 00000085 ??                  <1>     .ctrlCExit   db ?  ;-1 => CTRL+BREAK termination, 0 otherwise
    55 00000086 ??                  <1>     .fcbSpaceOk  db ?  ;If set, we allow embedded spaces in the filenames
    56 00000087 ??                  <1>     .dayOfMonth  db ?  ;01h - 1Fh (1 - 31)
    57 00000088 ??                  <1>     .monthOfYear db ?  ;01h - 0Ch (1 - 12)
    58 00000089 ??                  <1>     .years       db ?  ;00h - 7Fh (00 = 1980 - 127 = 2107)
    59 0000008A ????                <1>     .daysOffset  dw ?  ;Days since 1-1-1980
    60 0000008C ??                  <1>     .dayOfWeek   db ?  ;0 = Sunday <-> 6 = Saturday
    61 0000008D ??                  <1>     .vConDrvSwp  db ?  ;Set if vCon controlled by a different driver to vConPtr
    62 0000008E ??                  <1>     .int28Flag   db ?  ;If set, Int 28h should be called, if clear no
    63 0000008F ??                  <1>     .Int24Trans  db ?  ;Set to -1 if Abort translated to Fail
    64 00000090 <res 2Ah>           <1>     .secdReqPkt  db ioReqPkt_size dup (?) ;Secondary, Char IO Reqhdr
    65 000000BA <res 2Ah>           <1>     .primReqPkt  db ioReqPkt_size dup (?) ;Main Drv Reqhdr 
    66 000000E4 <res 2Ah>           <1>     .critReqPkt  db ioReqPkt_size dup (?)  ;Used for ^C detection!
    67 0000010E ??                  <1>     .pspCopyFlg  db ?  ;Set to -1 for child process PSP, 0 for simple PSP copy
    68 0000010F ????????????        <1>     .CLOCKrecrd  db 6 dup (?)  ;Clock driver record
    69 00000115 ????                <1>     .singleIObyt dw ?  ;For single IO byte buffers
    70 00000117 <res 80h>           <1>     .buffer1     db 128 dup (?)  ;Space for one path and file name
    71 00000197 <res 80h>           <1>     .buffer2     db 128 dup (?) ;Space for a second path and file name
    72 00000217 ????????????????    <1>     .fname1Ptr   dq ?  ;Ptr to first filename argument
    73 0000021F ????????????????    <1>     .fname2Ptr   dq ?  ;Ptr to second filename argument
    74 00000227 ??                  <1>     .skipDisk    db ?  ;Set => Read Disk, Clear => Skip checking on disk
    75 00000228 <res 2Bh>           <1>     .dosffblock  db ffBlock_size dup (?)  ;FF block (fullsize unlike DOS)
    76 00000253 <res 20h>           <1>     .curDirCopy  db fatDirEntry_size dup (?)  ;Dir copy
    77                              <1> endstruc
    19                                  %include "./src/main.asm"
     1                              <1> ;Subst main routine
     2                              <1> startMain:
     3 00000000 EB01                <1>     jmp short .cVersion
     4 00000002 01                  <1> .vNum:  db 1
     5                              <1> .cVersion:
     6 00000003 488D25(02020000)    <1>     lea rsp, endOfAlloc   ;Move RSP to our internal stack
     7                              <1> ;Do a version check since this version cannot check the number of rows/cols
     8 0000000A FC                  <1>     cld
     9 0000000B B800300000          <1>     mov eax, 3000h
    10 00000010 CD21                <1>     int 21h
    11 00000012 3A05EAFFFFFF        <1>     cmp al, byte [.vNum]    ;Version number 1 check
    12 00000018 7615                <1>     jbe short okVersion
    13 0000001A 488D15DC040000      <1>     lea rdx, badVerStr
    14                              <1> badPrintExit:
    15 00000021 B800090000          <1>     mov eax, 0900h
    16 00000026 CD21                <1>     int 21h
    17 00000028 B8FF4C0000          <1>     mov eax, 4CFFh
    18 0000002D CD21                <1>     int 21h
    19                              <1> okVersion:
    20                              <1> ;Now we init the BSS to 0.
    21 0000002F 488D3D(00000000)    <1>     lea rdi, bssStart
    22 00000036 31C0                <1>     xor eax, eax
    23 00000038 B99A000000          <1>     mov ecx, bssLen
    24 0000003D F3AA                <1>     rep stosb
    25                              <1> ;Now let us resize ourselves so as to take up as little memory as possible
    26 0000003F 488D1D(02020000)    <1>     lea rbx, endOfAlloc ;Number of bytes of the allocation
    27 00000046 4C29C3              <1>     sub rbx, r8
    28 00000049 81C30F000000        <1>     add ebx, 0Fh        ;Round up
    29 0000004F C1EB04              <1>     shr ebx, 4          ;Turn into number of paragraphs
    30 00000052 B8004A0000          <1>     mov eax, 4A00h
    31 00000057 CD21                <1>     int 21h ;If this fails, we still proceed as we are just being polite!
    32                              <1> ;Now get the sysvars pointer and save it in var.
    33                              <1> ;This cannot change so it is fine to do it out of a critical section.
    34 00000059 B800520000          <1>     mov eax, 5200h
    35 0000005E CD21                <1>     int 21h
    36 00000060 48891D(00000000)    <1>     mov qword [pSysvars], rbx
    37                              <1> parseCmdLine:
    38                              <1> ;Now parse the command line
    39 00000067 498DB081000000      <1>     lea rsi, qword [r8 + psp.progTail]
    40 0000006E 31C9                <1>     xor ecx, ecx    ;Keep a count of vars on cmd line in ecx
    41 00000070 E83A040000          <1>     call skipDelims ;Goto the first non-delimiter char
    42 00000075 3C0D                <1>     cmp al, CR
    43 00000077 7441                <1>     je endParse
    44 00000079 488935(08000000)    <1>     mov qword [pVar1], rsi    ;Save the ptr to the first var
    45 00000080 FFC1                <1>     inc ecx
    46 00000082 E834040000          <1>     call findDelimOrCR
    47 00000087 3C0D                <1>     cmp al, CR
    48 00000089 742F                <1>     je endParse
    49 0000008B E81F040000          <1>     call skipDelims
    50 00000090 488935(10000000)    <1>     mov qword [pVar2], rsi    ;Save the ptr to the second var
    51 00000097 FFC1                <1>     inc ecx
    52 00000099 E81D040000          <1>     call findDelimOrCR
    53 0000009E 3C0D                <1>     cmp al, CR  ;The second arg shouldve been the last arg
    54 000000A0 7418                <1>     je endParse
    55                              <1> badPrmsExit:
    56                              <1> ;Too many parameters and/or badly formatted cmdline error
    57 000000A2 488D156C040000      <1>     lea rdx, badPrmsStr
    58 000000A9 E973FFFFFF          <1>     jmp badPrintExit
    59                              <1> badParmExit:
    60                              <1> ;Bad but valid parameter passed in
    61 000000AE 488D1581040000      <1>     lea rdx, badParmStr
    62 000000B5 E967FFFFFF          <1>     jmp badPrintExit
    63                              <1> endParse:
    64 000000BA 85C9                <1>     test ecx, ecx
    65 000000BC 0F844B030000        <1>     jz printSubst   ;If no arguments found, print the substs!
    66 000000C2 81F901000000        <1>     cmp ecx, 1      
    67 000000C8 74D8                <1>     je badPrmsExit  ;Cannot have just 1 argument on the cmdline
    68 000000CA B800370000          <1>     mov eax, 3700h  ;Get switchchar in dl
    69 000000CF CD21                <1>     int 21h
    70 000000D1 31C9                <1>     xor ecx, ecx    ;Use as cntr (1 or 2) to indicate which var has ptr to /D
    71 000000D3 488B35(08000000)    <1>     mov rsi, qword [pVar1]
    72 000000DA 3816                <1>     cmp byte [rsi], dl
    73 000000DC 7509                <1>     jne .g2
    74 000000DE E897030000          <1>     call checkSwitchOk  ;Now check rsi points to a bona fide /D 
    75 000000E3 72BD                <1>     jc badPrmsExit
    76 000000E5 FFC1                <1>     inc ecx
    77                              <1> .g2:
    78 000000E7 488B35(10000000)    <1>     mov rsi, qword [pVar2]
    79 000000EE 3816                <1>     cmp byte [rsi], dl
    80 000000F0 7510                <1>     jne .switchDone
    81 000000F2 85C9                <1>     test ecx, ecx   ;Var2 can be /D ONLY IF Var1 was not /D
    82 000000F4 75AC                <1>     jnz badPrmsExit
    83 000000F6 E87F030000          <1>     call checkSwitchOk  ;Now check rsi points to a bona fide /D 
    84 000000FB 72A5                <1>     jc badPrmsExit
    85 000000FD B902000000          <1>     mov ecx, 2      ;Else, indicate var2 has the /D flag!
    86                              <1> .switchDone:
    87 00000102 85C9                <1>     test ecx, ecx   ;If ecx is zero, then we are adding a subst.
    88 00000104 0F84D5000000        <1>     jz addSubst
    89                              <1> ;Else we are deleting a subst drive.
    90                              <1> delSubst:
    91 0000010A 488B35(08000000)    <1>     mov rsi, qword [pVar1]
    92 00000111 488B3D(10000000)    <1>     mov rdi, qword [pVar2]
    93 00000118 81F901000000        <1>     cmp ecx, 1          ;If ecx = 1, rsi points to the /D
    94 0000011E 480F45FE            <1>     cmovne rdi, rsi     ;Make rdi point to the drive letter!
    95                              <1> ;rdi points to the drive letter in cmdline. Check it is legit.
    96 00000122 8A4702              <1>     mov al, byte [rdi + 2]
    97 00000125 E89D030000          <1>     call isALDelimOrCR  ;Ensure the string length is 2!
    98 0000012A 0F8572FFFFFF        <1>     jne badPrmsExit
    99 00000130 807F013A            <1>     cmp byte [rdi + 1], ":"
   100 00000134 0F8568FFFFFF        <1>     jne badPrmsExit
   101                              <1> ;Here the char is legit! Now UC it and use it as offset into CDS
   102                              <1> ; to deactivate it!
   103 0000013A 0FB607              <1>     movzx eax, byte [rdi]
   104 0000013D 50                  <1>     push rax
   105 0000013E B813120000          <1>     mov eax, 1213h  ;UC char
   106 00000143 CD2F                <1>     int 2Fh
   107 00000145 0FB6C8              <1>     movzx ecx, al   ;Move the UC char into ecx
   108 00000148 58                  <1>     pop rax         ;Rebalance the stack
   109 00000149 81E941000000        <1>     sub ecx, "A"    ;Turn into an offset into CDS
   110                              <1> ;Check if we are deleting the current drive.
   111 0000014F B800190000          <1>     mov eax, 1900h  ;Get current drive
   112 00000154 CD21                <1>     int 21h
   113 00000156 38C8                <1>     cmp al, cl  ;If we are deleting the current drive, error exit!
   114 00000158 0F8450FFFFFF        <1>     je badParmExit
   115                              <1> ;Check if the subst drive we want to deactivate is a valid drive
   116                              <1> ; in our system (i.e. does such a drive entry exist in the CDS array)
   117 0000015E E838030000          <1>     call enterDOSCrit   ;Enter crit, Exit in the exit routine!
   118 00000163 488B1D(00000000)    <1>     mov rbx, qword [pSysvars]   
   119                              <1> ;If drive specified to remove is past end of CDS array, error!
   120 0000016A 384B3D              <1>     cmp byte [rbx + sysVars.lastdrvNum], cl
   121 0000016D 7666                <1>     jbe .error
   122                              <1> ;Point rdi to the cds we are adjusting.
   123 0000016F 488B7B2A            <1>     mov rdi, qword [rbx + sysVars.cdsHeadPtr]   ;Point rdi to cds array
   124 00000173 B85F000000          <1>     mov eax, cds_size
   125 00000178 F7E1                <1>     mul ecx
   126 0000017A 81C141000000        <1>     add ecx, "A"    ;Turn offset back into a UC drive letter!
   127 00000180 4801C7              <1>     add rdi, rax    ;rdi now points to the right CDS
   128                              <1> ;Check the cds we have chosen is really a subst drive
   129 00000183 66F747430010        <1>     test word [rdi + cds.wFlags], cdsSubstDrive
   130 00000189 744A                <1>     jz .error      ;If this CDS is not a subst drive, error!
   131                              <1> ;Start editing the CDS back to it's default state
   132 0000018B 880F                <1>     mov byte [rdi], cl  ;Place the drive letter...
   133 0000018D 66C747025C00        <1>     mov word [rdi + 2], "\"   ;... and root backslash with null terminator!
   134 00000193 C6475D02            <1>     mov byte [rdi + cds.wBackslashOffset], 2    ;Go to root!
   135 00000197 C7474D00000000      <1>     mov dword [rdi + cds.dStartCluster], 0      ;Set start cluster for root!
   136                              <1> ;Deactivate the subst but also the drive possibly temporarily!
   137 0000019E 66816743FFAF        <1>     and word [rdi + cds.wFlags], ~(cdsSubstDrive | cdsValidDrive)
   138                              <1> ;Check for a physical DPB for this drive letter.
   139                              <1> ;I.E if drive D selected, search for the fourth DPB.
   140 000001A4 81E941000000        <1>     sub ecx, "A"    ;Turn ecx back into a 0 based drive number
   141                              <1> ;If the drive number is above the number of physical drives, we 
   142                              <1> ; ignore the search as the physical drives always populate the 
   143                              <1> ; first drives. Acts as a minor optimisation to avoid walking DPB linked list.
   144 000001AA 3A4B3C              <1>     cmp cl, byte [rbx + sysVars.numPhysVol]
   145 000001AD 7715                <1>     ja .exit    ;If drv num > physical drvs, we ignore this search!
   146                              <1> ;Search the DPB linked list for the drive number associated to this drive!
   147 000001AF 488B2B              <1>     mov rbp, qword [rbx + sysVars.dpbHeadPtr]
   148                              <1> .lp:
   149 000001B2 384D00              <1>     cmp byte [rbp + dpb.bDriveNumber], cl
   150 000001B5 7412                <1>     je .dpbFnd  ;If DPB found for the drive in cl, 
   151 000001B7 488B6D25            <1>     mov rbp, qword [rbp + dpb.qNextDPBPtr]
   152 000001BB 4881FDFFFFFFFF      <1>     cmp rbp, -1 ;We should never fall through but still better to be safe!
   153 000001C2 75EE                <1>     jne .lp
   154                              <1> .exit:
   155 000001C4 E9A5020000          <1>     jmp exit
   156                              <1> .dpbFnd:
   157 000001C9 48896F45            <1>     mov qword [rdi + cds.qDPBPtr], rbp  ;Set this DPB as the CDS DPB!
   158 000001CD 66814F430040        <1>     or word [rdi + cds.wFlags], cdsValidDrive   ;Reactivate this drive!
   159 000001D3 EBEF                <1>     jmp short .exit
   160                              <1> .error:
   161                              <1> ;Invalid drive specified!
   162 000001D5 E8CB020000          <1>     call exitDOSCrit    ;Exit the critical section before exiting!!
   163 000001DA E9CFFEFFFF          <1>     jmp badParmExit
   164                              <1>     
   165                              <1> addSubst:
   166                              <1> ;Here we add the subst path. We gotta check that path provided
   167                              <1> ; exists! It is not null terminated so we gotta null terminate it.
   168                              <1> ; We also gotta get rid of any trailing slashes from the path provided!
   169                              <1> ;
   170                              <1> ;Drive1 can be valid, be cannot be a subst, join or net drive!
   171                              <1> ;
   172 000001DF 488B35(08000000)    <1>     mov rsi, qword [pVar1]
   173 000001E6 E8D0020000          <1>     call findDelimOrCR
   174 000001EB C60600              <1>     mov byte [rsi], 0   ;Null terminate var1
   175 000001EE 488B35(10000000)    <1>     mov rsi, qword [pVar2]
   176 000001F5 E8C1020000          <1>     call findDelimOrCR
   177 000001FA C60600              <1>     mov byte [rsi], 0   ;Null terminate var2
   178                              <1> 
   179 000001FD 31ED                <1>     xor ebp, ebp        ;Use rbp as the ptr to the drive spec string
   180                              <1> 
   181 000001FF 488B35(08000000)    <1>     mov rsi, qword [pVar1]  ;Check if var1 is drive specification
   182 00000206 66817E013A00        <1>     cmp word [rsi + 1], ":" ;Is pVar1 a drive specification?
   183 0000020C 480F44EE            <1>     cmove rbp, rsi  ;Move the ptr to the drive specifier into rbp
   184                              <1> 
   185 00000210 488B35(10000000)    <1>     mov rsi, qword [pVar2]  ;Check if var2 is drive specification
   186 00000217 66817E013A00        <1>     cmp word [rsi + 1], ":" ;Is pVar2 a drive specification?
   187 0000021D 750C                <1>     jne .gotDrvSpec
   188 0000021F 4885ED              <1>     test rbp, rbp   ;rbp must be null, else two drives were specified. Error!
   189 00000222 0F8586FEFFFF        <1>     jnz badParmExit ;Cmdline valid but invalid data passed!
   190 00000228 4889F5              <1>     mov rbp, rsi    ;Set rbp to point to the drive
   191                              <1> .gotDrvSpec:
   192                              <1> ;Come here with rbp pointing to the new subst drive spec. 
   193 0000022B 0FB64500            <1>     movzx eax, byte [rbp]
   194 0000022F 50                  <1>     push rax
   195 00000230 B813120000          <1>     mov eax, 1213h  ;UC the char in al
   196 00000235 CD2F                <1>     int 2Fh
   197 00000237 2C41                <1>     sub al, "A"     ;Turn into a 0 based drive number
   198 00000239 8805(19000000)      <1>     mov byte [destDrv], al
   199 0000023F 58                  <1>     pop rax
   200                              <1> ;Make rsi point to the other argument!
   201 00000240 488B35(08000000)    <1>     mov rsi, qword [pVar1]
   202 00000247 488B3D(10000000)    <1>     mov rdi, qword [pVar2]
   203 0000024E 4839F5              <1>     cmp rbp, rsi  ;if rbp -> var1...  
   204 00000251 480F44F7            <1>     cmove rsi, rdi  ;... make rsi -> var2. Else, rsi -> var1
   205                              <1> ;rsi -> ASCIIZ path. Must check it is a legit path.
   206 00000255 488D3D(1A000000)    <1>     lea rdi, qword [inCDS + cds.sCurrentPath]
   207 0000025C B81A120000          <1>     mov eax, 121Ah
   208 00000261 CD2F                <1>     int 2Fh
   209 00000263 0F8245FEFFFF        <1>     jc badParmExit  ;Bad drive selected if CF=CY
   210 00000269 84C0                <1>     test al, al
   211 0000026B 7509                <1>     jnz .notDefault
   212 0000026D B800190000          <1>     mov eax, 1900h
   213 00000272 CD21                <1>     int 21h
   214 00000274 FFC0                <1>     inc eax
   215                              <1> .notDefault:
   216 00000276 89C2                <1>     mov edx, eax    ;Save 1 based drive number in dl
   217 00000278 FFC8                <1>     dec eax         ;Convert the drive number to 0 based
   218 0000027A 3A05(19000000)      <1>     cmp al, byte [destDrv]  ;Check drive numbers are not equal 
   219 00000280 0F8428FEFFFF        <1>     je badParmExit
   220 00000286 8805(18000000)      <1>     mov byte [srcDrv], al   ;Save the drive letter in the var 
   221 0000028C 0441                <1>     add al, "A"
   222 0000028E B43A                <1>     mov ah, ":"
   223 00000290 66AB                <1>     stosw   ;Store drive letter 
   224 00000292 31C0                <1>     xor eax, eax
   225 00000294 AC                  <1>     lodsb   ;Get the first char of the path now and adv char ptr
   226 00000295 3C5C                <1>     cmp al, "\"
   227 00000297 742A                <1>     je .pathSepFnd
   228 00000299 3C2F                <1>     cmp al, "/"
   229 0000029B B05C                <1>     mov al, "\"     ;No pathsep (relpath) or unix pathsep given
   230 0000029D 7424                <1>     je .pathSepFnd
   231 0000029F 48FFCE              <1>     dec rsi         ;Return the source ptr to the first char again!
   232 000002A2 AA                  <1>     stosb           ;Store the pathsep and adv rdi
   233 000002A3 56                  <1>     push rsi        ;Save the source pointer
   234 000002A4 4889FE              <1>     mov rsi, rdi    ;Store the rest of the path here
   235 000002A7 B800470000          <1>     mov eax, 4700h  ;Get the Current Directory for current drive
   236 000002AC CD21                <1>     int 21h
   237 000002AE 5E                  <1>     pop rsi         ;Get back the pointer to the source in rsi
   238 000002AF 31C0                <1>     xor eax, eax
   239 000002B1 B9FFFFFFFF          <1>     mov ecx, -1
   240 000002B6 F2AE                <1>     repne scasb     ;Move rdi past the terminating null
   241 000002B8 48FFCF              <1>     dec rdi         ;And point back to it
   242 000002BB 807FFF5C            <1>     cmp byte [rdi - 1], "\" ;Skip adding extra pathsep if one present (rt only)
   243 000002BF 7403                <1>     je .cplp
   244 000002C1 B05C                <1>     mov al, "\"
   245                              <1> .pathSepFnd:
   246 000002C3 AA                  <1>     stosb           ;Store the normalised pathsep
   247                              <1> ;Now copy the path specified by rsi to rdi. rsi is null terminated string
   248                              <1> .cplp:
   249 000002C4 AC                  <1>     lodsb
   250 000002C5 AA                  <1>     stosb
   251 000002C6 84C0                <1>     test al, al
   252 000002C8 75FA                <1>     jnz .cplp
   253                              <1> ;Now we normalise the CDS string and check it is of len leq 67
   254 000002CA 488D35(1A000000)    <1>     lea rsi, inCDS
   255 000002D1 4889F7              <1>     mov rdi, rsi
   256 000002D4 B811120000          <1>     mov eax, 1211h  ;Normalise string (UC and swap slashes.)
   257 000002D9 CD2F                <1>     int 2Fh
   258 000002DB B812120000          <1>     mov eax, 1212h  ;Strlen (including terminating null)
   259 000002E0 CD2F                <1>     int 2Fh
   260 000002E2 81F943000000        <1>     cmp ecx, 67
   261 000002E8 0F87C0FDFFFF        <1>     ja badParmExit
   262                              <1> ;Now the CDS string is setup :) 
   263                              <1> ;We now enter the critical section and 
   264                              <1> ; check the CDS string is a path to a directory!
   265 000002EE E8A8010000          <1>     call enterDOSCrit   ;Now enter DOS critical section
   266                              <1> 
   267 000002F3 488D15(1A000000)    <1>     lea rdx, qword [inCDS + cds.sCurrentPath]
   268 000002FA 8B02                <1>     mov eax, dword [rdx]
   269 000002FC C1E808              <1>     shr eax, 8  ;Drop the drive letter
   270 000002FF 3D3A5C0000          <1>     cmp eax, ":\"
   271 00000304 743F                <1>     je .rtDir   ;Root dir specified (check that FF doesnt fail this case)
   272 00000306 B8004E0000          <1>     mov eax, 4E00h
   273 0000030B B910000000          <1>     mov ecx, 10h    ;Subdir flag
   274 00000310 CD21                <1>     int 21h
   275 00000312 7311                <1>     jnc .dirFnd
   276 00000314 488D152F020000      <1>     lea rdx, badPathStr ;Bad path passed for substing
   277 0000031B E885010000          <1>     call exitDOSCrit
   278 00000320 E9FCFCFFFF          <1>     jmp badPrintExit
   279                              <1> .dirFnd:
   280 00000325 B8065D0000          <1>     mov eax, 5D06h  ;Get SDA ptr in rsi
   281 0000032A CD21                <1>     int 21h
   282 0000032C 0FB7966D020000      <1>     movzx edx, word [rsi + sda.curDirCopy + fatDirEntry.fstClusLo]
   283 00000333 0FB78667020000      <1>     movzx eax, word [rsi + sda.curDirCopy + fatDirEntry.fstClusHi]
   284 0000033A C1E010              <1>     shl eax, 10h
   285 0000033D 09D0                <1>     or eax, edx ;Add low bits to eax
   286 0000033F 8905(67000000)      <1>     mov dword [inCDS + cds.dStartCluster], eax  ;Replace with real start clust
   287                              <1> .rtDir:
   288                              <1> ;The path provided is a valid directory. Start cluster in CDS (0 if root dir)
   289                              <1> ;Now check the selected destination CDS is valid!
   290 00000345 488B1D(00000000)    <1>     mov rbx, qword [pSysvars]
   291 0000034C 0FB60D(19000000)    <1>     movzx ecx, byte [destDrv]
   292 00000353 384B3D              <1>     cmp byte [rbx + sysVars.lastdrvNum], cl
   293 00000356 770A                <1>     ja .destNumOk ;Has to be above zero as cl is 0 based :)
   294                              <1>     ;ERROR: DRIVE PAST THE LAST DRIVE VALUE!
   295                              <1> .inDOSBadExit:
   296 00000358 E848010000          <1>     call exitDOSCrit
   297 0000035D E94CFDFFFF          <1>     jmp badParmExit
   298                              <1> .destNumOk:
   299 00000362 E897000000          <1>     call .getCds    ;Get the CDS ptr for the destination in rdi
   300                              <1>     ;test word [rdi + cds.wFlags], cdsValidDrive
   301                              <1>     ;DO NOT CHECK VALIDITY AS WE CAN OVERWRITE A VALID LOCAL DRV
   302                              <1>     ;jnz .inDOSBadExit
   303 00000367 66F7474300B0        <1>     test word [rdi + cds.wFlags], cdsSubstDrive | cdsJoinDrive | cdsRedirDrive
   304 0000036D 7411                <1>     jz .destNotNet   
   305                              <1> ;ERROR: SPECIFIED CDS ENTRY ALREADY IN USE FOR REDIR!
   306                              <1> .inDOSBadNetExit:
   307 0000036F 488D1568010000      <1>     lea rdx, badNetStr
   308 00000376 E82A010000          <1>     call exitDOSCrit
   309 0000037B E9A1FCFFFF          <1>     jmp badPrintExit
   310                              <1> .destNotNet:
   311                              <1> ;Now we build the subst CDS.
   312 00000380 4889FD              <1>     mov rbp, rdi    ;Save the destination cds pointer in rbp
   313 00000383 0FB60D(18000000)    <1>     movzx ecx, byte [srcDrv]    
   314 0000038A E86F000000          <1>     call .getCds    ;Get source cds in rdi
   315 0000038F 66F7474300B0        <1>     test word [rdi + cds.wFlags], cdsSubstDrive | cdsJoinDrive | cdsRedirDrive
   316 00000395 75D8                <1>     jnz .inDOSBadNetExit
   317 00000397 66C705(5D000000)00- <1>     mov word [inCDS + cds.wFlags], cdsValidDrive | cdsSubstDrive
   317 0000039F 50                  <1>
   318 000003A0 488B7745            <1>     mov rsi, qword [rdi + cds.qDPBPtr]
   319 000003A4 488935(5F000000)    <1>     mov qword [inCDS + cds.qDPBPtr], rsi
   320 000003AB 488B7751            <1>     mov rsi, qword [rdi + cds.qIFSPtr]
   321 000003AF 488935(6B000000)    <1>     mov qword [inCDS + cds.qIFSPtr], rsi
   322 000003B6 8B7759              <1>     mov esi, dword [rdi + cds.dNetStore]
   323 000003B9 897759              <1>     mov dword [rdi + cds.dNetStore], esi
   324                              <1> ;Now compute the wBackslash offset
   325 000003BC 488D35(1A000000)    <1>     lea rsi, inCDS
   326 000003C3 B825120000          <1>     mov eax, 1225h  ;Get strlen of str pointed to by rsi in ecx
   327 000003C8 CD2F                <1>     int 2fh
   328 000003CA FFC9                <1>     dec ecx         ;Drop the terminating null from count
   329 000003CC 4801CE              <1>     add rsi, rcx    ;Go to last char
   330 000003CF 803E5C              <1>     cmp byte [rsi], "\"
   331 000003D2 750D                <1>     jne .notTrailing    ;No trailing slash, skip overwrite.
   332 000003D4 FFC9                <1>     dec ecx
   333 000003D6 81F902000000        <1>     cmp ecx, 2          ;If C:\, dont overwrite the slash
   334 000003DC 7403                <1>     je .notTrailing
   335 000003DE C60600              <1>     mov byte [rsi], 0   ;Else overwrite null over the trailing slash
   336                              <1> .notTrailing:
   337 000003E1 66890D(77000000)    <1>     mov word [inCDS + cds.wBackslashOffset], cx
   338 000003E8 4889EF              <1>     mov rdi, rbp
   339 000003EB 488D35(1A000000)    <1>     lea rsi, inCDS
   340 000003F2 B95F000000          <1>     mov ecx, cds_size
   341 000003F7 F3A4                <1>     rep movsb   ;Copy over the new CDS and exit!
   342 000003F9 E970000000          <1>     jmp exit
   343                              <1> .getCds:
   344                              <1> ;Input: ecx = [byte] 0-based drive number
   345                              <1> ;       rbx -> sysVars
   346                              <1> ;Output: rdi -> CDS for drive
   347 000003FE 488B7B2A            <1>     mov rdi, qword [rbx + sysVars.cdsHeadPtr]   ;Point rdi to cds array
   348 00000402 B85F000000          <1>     mov eax, cds_size
   349 00000407 F7E1                <1>     mul ecx
   350 00000409 4801C7              <1>     add rdi, rax    ;rdi now points to the right CDS
   351                              <1>     return
    13                              <2> %%_ret:
    14 0000040C C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   352                              <1> 
   353                              <1> 
   354                              <1> printSubst:
   355 0000040D E889000000          <1>     call enterDOSCrit   ;Ensure the CDS size and ptr doesnt change
   356 00000412 488B1D(00000000)    <1>     mov rbx, qword [pSysvars]
   357 00000419 488B7B2A            <1>     mov rdi, qword [rbx + sysVars.cdsHeadPtr]
   358 0000041D 0FB64B3D            <1>     movzx ecx, byte [rbx + sysVars.lastdrvNum]  ;Get # of CDS's
   359 00000421 BB41000000          <1>     mov ebx, "A"    
   360                              <1> .lp:
   361 00000426 66F747430010        <1>     test word [rdi + cds.wFlags], cdsSubstDrive
   362 0000042C 7433                <1>     jz .gotoNextCDS
   363                              <1> ;Print the CDS drive letter and the rocket
   364 0000042E 488D1526010000      <1>     lea rdx, substStr
   365 00000435 881A                <1>     mov byte [rdx], bl  ;Overwrite the drive letter in substStr
   366 00000437 B800090000          <1>     mov eax, 0900h      ;Print the substStr
   367 0000043C CD21                <1>     int 21h
   368                              <1> ;Print the current path of the cds upto the backslash offset
   369 0000043E 53                  <1>     push rbx
   370 0000043F 0FB74F5D            <1>     movzx ecx, word [rdi + cds.wBackslashOffset]
   371 00000443 488D17              <1>     lea rdx, qword [rdi + cds.sCurrentPath]
   372 00000446 BB01000000          <1>     mov ebx, 1          ;Print to STDOUT
   373 0000044B B800400000          <1>     mov eax, 4000h
   374 00000450 CD21                <1>     int 21h
   375 00000452 5B                  <1>     pop rbx
   376                              <1> ;Print a CRLF
   377 00000453 488D15B8000000      <1>     lea rdx, crlf
   378 0000045A B800090000          <1>     mov eax, 0900h
   379 0000045F CD21                <1>     int 21h
   380                              <1> .gotoNextCDS:
   381 00000461 4881C75F000000      <1>     add rdi, cds_size
   382 00000468 FFC3                <1>     inc ebx ;Goto next drive letter!
   383 0000046A FFC9                <1>     dec ecx
   384 0000046C 75B8                <1>     jnz .lp
   385                              <1> exit:
   386 0000046E E832000000          <1>     call exitDOSCrit
   387 00000473 B8004C0000          <1>     mov eax, 4C00h
   388 00000478 CD21                <1>     int 21h
   389                              <1> 
   390                              <1> ;------------------------------------------------------------------------
   391                              <1> ; Utility functions below!
   392                              <1> ;------------------------------------------------------------------------
   393                              <1> checkSwitchOk:
   394                              <1> ;Checks if the switch char is D and if the char following is a 
   395                              <1> ; delimiter or CR. 
   396                              <1> ;Input: rsi -> Possible /D. Points to the /
   397                              <1> ;Output: CF=CY: Not ok to proceed.
   398                              <1> ;        CF=NC: Ok to proceed
   399 0000047A 8A4601              <1>     mov al, byte [rsi + 1]
   400 0000047D 50                  <1>     push rax
   401 0000047E B813120000          <1>     mov eax, 1213h  ;UC char
   402 00000483 CD2F                <1>     int 2Fh
   403 00000485 3C44                <1>     cmp al, "D"
   404 00000487 58                  <1>     pop rax
   405 00000488 750F                <1>     jne .bad
   406 0000048A 8A4602              <1>     mov al, byte [rsi + 2]
   407 0000048D 3C0D                <1>     cmp al, CR  ;If equal, clears CF
   408                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26                              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29 0000048F 7501                <3>  j%-1 short %%a
    30                              <3>  return
    13                              <4> %%_ret:
    14 00000491 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   409 00000492 E834000000          <1>     call isALDelim  ;If return equal, we are ok!
   410                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 00000497 74(91)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   411                              <1> .bad:
   412 00000499 F9                  <1>     stc
   413                              <1>     return
    13                              <2> %%_ret:
    14 0000049A C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   414                              <1> 
   415                              <1> enterDOSCrit:
   416 0000049B 50                  <1>     push rax
   417 0000049C B801800000          <1>     mov eax, 8001h
   418 000004A1 CD2A                <1>     int 2Ah
   419 000004A3 58                  <1>     pop rax
   420                              <1>     return 
    13                              <2> %%_ret:
    14 000004A4 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   421                              <1> 
   422                              <1> exitDOSCrit:
   423 000004A5 50                  <1>     push rax
   424 000004A6 B801810000          <1>     mov eax, 8101h
   425 000004AB CD2A                <1>     int 2Ah
   426 000004AD 58                  <1>     pop rax
   427                              <1>     return 
    13                              <2> %%_ret:
    14 000004AE C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   428                              <1> 
   429                              <1> skipDelims:
   430                              <1> ;Points rsi to the first non-delimiter char in a string, loads al with value
   431 000004AF AC                  <1>     lodsb
   432 000004B0 E816000000          <1>     call isALDelim
   433 000004B5 74F8                <1>     jz skipDelims
   434                              <1> ;Else, point rsi back to that char :)
   435 000004B7 48FFCE              <1>     dec rsi
   436                              <1>     return
    13                              <2> %%_ret:
    14 000004BA C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   437                              <1> 
   438                              <1> findDelimOrCR:
   439                              <1> ;Point rsi to the first delim or cmdtail terminator, loads al with value
   440 000004BB AC                  <1>     lodsb
   441 000004BC E806000000          <1>     call isALDelimOrCR
   442 000004C1 75F8                <1>     jnz findDelimOrCR
   443 000004C3 48FFCE              <1>     dec rsi ;Point back to the delim or CR char
   444                              <1>     return
    13                              <2> %%_ret:
    14 000004C6 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   445                              <1> 
   446                              <1> isALDelimOrCR:
   447 000004C7 3C0D                <1>     cmp al, CR
   448                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004C9 74(C6)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   449                              <1> isALDelim:
   450 000004CB 3C20                <1>     cmp al, SPC
   451                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004CD 74(C6)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   452 000004CF 3C09                <1>     cmp al, TAB
   453                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004D1 74(C6)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   454 000004D3 3C3D                <1>     cmp al, "="
   455                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004D5 74(C6)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   456 000004D7 3C2C                <1>     cmp al, ","
   457                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004D9 74(C6)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   458 000004DB 3C3B                <1>     cmp al, ";"
   459                              <1>     return
    13                              <2> %%_ret:
    14 000004DD C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    20                                  %include "./dat/strings.asm"
     1                              <1> 
     2                              <1> ;SUBST data
     3                              <1> ;Strings
     4 000004DE 43616E6E6F74205355- <1> badNetStr   db "Cannot SUBST a network drive",CR,LF,"$"
     4 000004E7 4253542061206E6574- <1>
     4 000004F0 776F726B2064726976- <1>
     4 000004F9 650D0A24            <1>
     5 000004FD 496E636F7272656374- <1> badVerStr   db "Incorrect DOS Version"    ;Ends on the next line
     5 00000506 20444F532056657273- <1>
     5 0000050F 696F6E              <1>
     6 00000512 0A0D24              <1> crlf        db LF,CR,"$"
     7 00000515 496E636F7272656374- <1> badPrmsStr  db "Incorrect number of parameters",CR,LF,"$"
     7 0000051E 206E756D626572206F- <1>
     7 00000527 6620706172616D6574- <1>
     7 00000530 6572730D0A24        <1>
     8 00000536 496E76616C69642070- <1> badParmStr  db "Invalid parameter",CR,LF,"$"
     8 0000053F 6172616D657465720D- <1>
     8 00000548 0A24                <1>
     9 0000054A 50617468206E6F7420- <1> badPathStr  db "Path not found",CR,LF,"$"
     9 00000553 666F756E640D0A24    <1>
    10 0000055B 5F3A203D3E2024      <1> substStr    db "_: => $"
    21                                  ;Use a 45 QWORD stack
    22                                  Segment transient align=8 follows=.text nobits
    23                                  %include "./dat/bss.asm"
     1                              <1> ;BSS data
     2                              <1> bssStart:
     3 00000000 ????????????????    <1> pSysvars    dq ?
     4 00000008 ????????????????    <1> pVar1       dq ?
     5 00000010 ????????????????    <1> pVar2       dq ?
     6                              <1> ;Used for create subst
     7 00000018 ??                  <1> srcDrv  db ?    ;0 based drive number of source drive of the SUBST
     8 00000019 ??                  <1> destDrv db ?    ;0 based drive number of the SUBST drive!
     9 0000001A <res 5Fh>           <1> inCDS   db cds_size dup (?)   ;ASCIIZ path to the host directory
    10 00000079 <res 21h>           <1>         db (128 - cds_size) dup (?)   ;Padding for if the string is too long!
    11                              <1> bssLen equ $ - bssStart
    24 0000009A <res 168h>                  dq 45 dup (?)
    25                                  endOfAlloc:
    25          ------------------       info: assembly required 1+2+2 passes

